## Quick Settings - configure common code style and other settings here. -----------------------------------------------
## Set these to use special prefixes for test class members containing dependencies of certain types.
## Note that the template code below will ignore any prefix set to "" and use your IDE code style settings instead.
#set($dependencyMemberNamePrefix = "")
#set($mockDependencyMemberNamePrefix = "mock")
## Set this to use a special prefix for local fields containing arguments for test methods.
#set($parameterLocalFieldNamePrefix = "")
#set($mockParameterLocalFieldNamePrefix = "mock")
## Customize the name of the member and local field (if needed) used to store the instance of the source class.
#set($sourceClass.testClassMemberName = "${sourceClass.testClassMemberName}UnderTest")
#set($sourceClass.testClassLocalFieldName = "${sourceClass.testClassLocalFieldName}UnderTest")
#set($shouldUseMockitoExtension = $ClassUtils.isInTestClasspath('org.mockito.runners.MockitoJUnitRunner') || $ClassUtils.isInTestClasspath('org.mockito.junit.MockitoJUnitRunner') || !$ClassUtils.isInTestClasspath('org.mockito.Mockito'))
#set($shouldUseMockitoBdd = false)
## Configure how Bean DTOs are initialized.
#set($minNumberOfSettersToCall = 15)
#set($maxNumberOfSettersToCall = 70)
#set($useStaticImportForInitMocks = true)
## Set this to use mocks for mockable method parameters that end in "listener" or "callback" ignoring case.
#set($useMocksForListenerAndCallbackParameters = true)
#set($generateStubsAndVerifyStatements = true)
## Use this to specify custom initialization values for dependencies and method parameters of certain types;
## See https://squaretest.com#template_api_quick_settings for details.
#set($initExpressionOverrides = {} )
##----------------------------------------------------------------------------------------------------------------------

## Initialize the data model. This sets global variables based on the architype of the source class and Quick Settings.
## See the comments above the macro or https://squaretest.com#template_api_initializeTemplateDataModel for details.
#initializeTemplateDataModel()

## Package declaration
#if($StringUtils.isNotEmpty($sourceClass.packageName))
        package $sourceClass.packageName;
#end

## Imports; Note that Squaretest invokes IntelliJ's import organize and code reformatter after creating the test class.
#foreach($importLine in $importLinesRequired)
    $importLine
#end
#if($useStaticImportForInitMocks)
import static org.mockito.MockitoAnnotations.$initMocksMethodName;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.spy;
#end
import java.util.concurrent.Callable;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.Future;
import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatThrownBy;
import static org.assertj.core.api.Assertions.within;
#if($shouldUseMockitoBdd)
import static org.mockito.BDDMockito.willAnswer;
import static org.mockito.BDDMockito.willReturn;
import static org.mockito.BDDMockito.willThrow;
import static org.mockito.BDDMockito.then;
import static org.mockito.BDDMockito.given;
#else
import static org.mockito.Mockito.doAnswer;
import static org.mockito.Mockito.doReturn;
import static org.mockito.Mockito.doThrow;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;
#end
import ${mockitoRunnerCanonicalName};
import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.mockito.MockitoAnnotations;
import org.mockito.InjectMocks;
import org.mockito.stubbing.Answer;
import org.springframework.test.web.servlet.MockMvc;
import org.apache.commons.lang3.StringUtils;
import com.alibaba.fastjson.JSONObject;
import org.springframework.test.web.servlet.request.MockMvcRequestBuilders;
import org.springframework.test.web.servlet.MvcResult;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;
import org.springframework.http.MediaType;

## Test class
#if($mocksNeeded && $shouldUseMockitoExtension)
@RunWith(${mockitoRunnerName}.class)
#end
public class ${sourceClass.name}Test {

    private MockMvc mockMvc;

    private String prefix;

    ## Declare member fields for the dependencies.
    #renderMemberDeclarations($mockMemberFields)
    #renderMemberDeclarations($nonMockMemberFields)

    ## Declare a member field for the instance of the source class.
    @InjectMocks
    private ${sourceClass.type.canonicalText} ${sourceClass.testClassMemberName};

    #if($mocksNeeded && !$shouldUseMockitoExtension && $hasOpenMocksMethod)
        private AutoCloseable mockitoCloseable;
    #end

    @Before
    public void setUp() throws Exception {
        this.mockMvc = MockMvcBuilders.standaloneSetup(${sourceClass.testClassMemberName}).build();
        #initializeTemplateDataModel()
        this.prefix = StringUtils.replace("$basePath", " ", "");
    }
    #if($mocksNeeded && !$shouldUseMockitoExtension && $hasOpenMocksMethod)
        @After
        public void tearDown() throws Exception {
            mockitoCloseable.close();
        }
    #end
    ## Render the test methods.
    #if($shouldCreateTestsForInstanceMethods)
        #renderTestMethods($sourceClass.instanceMethods.filterOut('private'))
    #end
    #renderTestMethods($sourceClass.staticMethods.filterOut('private'))
}

## Macros
## Add your own macros here. Newlines between macros will not appear in the generated test class;
## Squaretest automatically removes all but 1 newline at the end of the generated test class.

##----------------------------------------------------------------------------------------------------------------------
## renderMemberDeclarations($fields)
## Renders test-class member declarations for the given List<Variable>.
## Param: $fields - the list of variables for which to render declarations.
##----------------------------------------------------------------------------------------------------------------------
#macro(renderMemberDeclarations $fields)
    #foreach($field in $fields)
        #if($field.shouldBeMocked) @Mock #end
    private $field.type.canonicalText $field.testClassMemberName;
    #end
#end

##----------------------------------------------------------------------------------------------------------------------
## renderTestMethods($methods)
## Renders tests for the given List<Method>. This filters out getters/setters and other methods for which tests should
## not be rendered.
## Param: $methods - the list of methods for which to render tests.
##----------------------------------------------------------------------------------------------------------------------
#macro(renderTestMethods $methods)
    #if($sourceClass.enum)
        #set($macro.methodsToUse = $methods)
    #else
        #set($macro.methodsToUse = $methods.filterOut('simpleGetterOrSetter').filterOut('abstract'))
    #end
    #foreach($method in $macro.methodsToUse)
        #if($method.shouldUseSimpleTest)
            #renderSimpleTestMethod($method)
        #else
            #renderTestMethodForPrimaryFlow($method)
            #renderTestMethodsForAltFlows($method)
        #end
    #end
#end

##----------------------------------------------------------------------------------------------------------------------
## renderTestMethodForPrimaryFlow($method)
## Renders primary flow test case for the given Method.
## Param: $method - the method for which to render the test.
##----------------------------------------------------------------------------------------------------------------------
#macro(renderTestMethodForPrimaryFlow $method)
    #set($macro.mockedDIs = $method.dependencyInteractions.satisfiedBy($dependencies.filter('shouldBeMocked')))
    #set($macro.testInfo = $TestInfo.primaryFlow($method, $macro.mockedDIs))
    #renderTestMethod($macro.testInfo)
#end

##----------------------------------------------------------------------------------------------------------------------
## renderTestMethodsForAltFlows($method)
## Renders test for alternate flows for the given method.
## Param: $method - the method for which to render alt-flow tests.
##----------------------------------------------------------------------------------------------------------------------
#macro(renderTestMethodsForAltFlows $method)
    ## Render tests for exceptions declared by the source method.
    ## Determine if at at least one dependency interaction that we've mocked throws an exception.
    #set($macro.mockedDIs = $method.dependencyInteractions.satisfiedBy($dependencies.filter('shouldBeMocked')))
    #set($macro.shouldRenderTestsForIoParams = $method.static || !($sourceClass.enumValues.size() > 1))
    #set($macro.runtimeOrNonJdkExRegex = '(java\.lang\.RuntimeException|^(?!java\.).+)')
    #set($macro.atLeastOneMockedDiThrows = $macro.mockedDIs.containsAnyWith('method.throwsException', true) || $macro.mockedDIs.containsAnyWithNonNull('method.returnType.brokenIoInitExpression') || $macro.mockedDIs.flatMap('method.javadocExceptions').containsAnyWithRegex('type.canonicalName', $macro.runtimeOrNonJdkExRegex))
    #set($macro.atLeastOneMockedDiReturnsFailure = $macro.mockedDIs.containsAnyWithNonNull('method.returnType.failureInitExpression'))
    #set($macro.atLeastOneParamHasIo = $method.parameters.containsAnyWithNonNull('type.brokenIoInitExpression'))
    ## Only render tests for the source method's declared exceptions if none of the source method's mocked DIs throw.
    ## If one of the mocked DIs throw, that test case will likely be the case where the source class throws the declared exception(s).
    #set($macro.shouldRenderTestsForDeclaredExceptions = !$macro.atLeastOneMockedDiThrows && !$macro.atLeastOneParamHasIo && !$macro.atLeastOneMockedDiReturnsFailure)
    #set($macro.allSourceMethodExceptions = $method.declaredExceptions.union($method.javadocExceptions, 'type.canonicalName'))
    #if(!$generateStubsAndVerifyStatements)
        #renderAltFlowTestsForDeclaredExceptions($method, $macro.allSourceMethodExceptions)
        #break
    #end
    ## Render alternate flow tests based on parameters.
    #if($macro.shouldRenderTestsForIoParams)
        #foreach($param in $method.parameters)
            #if($param.type.emptyIoInitExpression)
                #renderTestMethod($TestInfo.fromParamWithEmptyIo($method, $macro.mockedDIs, $param))
            #end
            #if($param.type.brokenIoInitExpression)
                #renderTestMethod($TestInfo.fromParamWithBrokenIo($method, $macro.mockedDIs, $param))
            #end
        #end
    #end
    ## Render alternate flow tests based on the dependency interactions.
    #foreach($di in $macro.mockedDIs)
        ## Determine info about the DI method return type.
        #set($macro.isListenableFuture = $ListenableFutureNames.contains($di.method.returnType.canonicalName))
        #set($macro.isStandardFuture = $StringUtils.equalsAny($di.method.returnType.canonicalName, 'java.util.concurrent.Future', 'java.util.concurrent.CompletableFuture', 'java.util.concurrent.CompletionStage'))
        #set($macro.isAnyFuture = $di.method.returnType.isAny('java.util.concurrent.Future'))
        #set($macro.firstTypeParamCanBeEmpty = $StringUtils.isNotEmpty($di.method.returnType.parameters.first.emptyInitExpression))
        #set($macro.firstTypeParamCanBeAbsent = $di.method.returnType.parameters.first.absentInitExpression && !$StringUtils.equals($di.method.returnType.parameters.first.absentInitExpression, 'null'))
        #set($macro.shouldRenderAbsentTest = !$di.field.type.isAny('java.util.concurrent.Executor') && !$di.returnValueIgnored &&
        ($di.method.returnTypeCanBeAbsent || ($macro.isListenableFuture && $macro.firstTypeParamCanBeAbsent)))
        #set($macro.shouldRenderEmptyTest = !$di.field.type.isAny('java.util.concurrent.Executor') && !$di.returnValueIgnored &&
        ($di.method.returnType.emptyInitExpression || ($macro.isListenableFuture && $macro.firstTypeParamCanBeEmpty)))
        #set($macro.shouldRenderEmptyIoTest = !$di.field.type.isAny('java.util.concurrent.Executor') &&
        ($di.method.returnType.emptyIoInitExpression || $di.method.returnType.dtoBeanWithInputIoProperty || ($macro.isListenableFuture && $di.method.returnType.parameters.first.emptyIoInitExpression)))
        #set($macro.shouldRenderBrokenIoTest = !$di.field.type.isAny('java.util.concurrent.Executor') &&
        ($di.method.returnType.brokenIoInitExpression || $di.method.returnType.dtoBeanWithInputIoProperty || ($macro.isListenableFuture && $di.method.returnType.parameters.first.brokenIoInitExpression)))
        #set($macro.shouldRenderFailureTest = !($di.field.type.isAny('java.util.concurrent.Executor') && $macro.isAnyFuture) && ($di.method.returnType.failureInitExpression || $macro.isStandardFuture || $macro.isListenableFuture))
        #if(!$di.method.declaredExceptions.empty)
            #set($macro.diExceptionsToUse = $di.method.declaredExceptions)
        #else
            #set($macro.diExceptionsToUse = $di.method.javadocExceptions.filterItemsWithRegex('type.canonicalName', $macro.runtimeOrNonJdkExRegex))
        #end
        #set($macro.diExceptionsToUse = $macro.diExceptionsToUse.union($di.method.undeclaredExceptions, 'type.canonicalName'))
        ## Render the alt flow tests.
        #if($macro.shouldRenderAbsentTest)
            ## Render the test case where this dependency interaction returns either null or an absent value.
            #renderTestMethod($TestInfo.fromDiToReturnAbsent($method, $macro.mockedDIs, $di))
        #end
        #if($macro.shouldRenderEmptyTest)
            ## Render the test case where this dependency interaction returns an empty value.
            #renderTestMethod($TestInfo.fromDiToReturnEmpty($method, $macro.mockedDIs, $di))
        #end
        #if($macro.shouldRenderEmptyIoTest)
            #renderTestMethod($TestInfo.fromDiToReturnEmptyIo($method, $macro.mockedDIs, $di))
        #end
        #if($macro.shouldRenderBrokenIoTest)
            #renderTestMethod($TestInfo.fromDiToReturnBrokenIo($method, $macro.mockedDIs, $di))
        #end
        #if($macro.shouldRenderFailureTest)
            #renderTestMethod($TestInfo.fromDiToReturnFailure($method, $macro.mockedDIs, $di))
        #end
        #foreach($exception in $macro.diExceptionsToUse)
            #renderTestMethod($TestInfo.fromDiThatThrows($method, $macro.mockedDIs, $di, $exception))
        #end
    #end
    #if($macro.shouldRenderTestsForDeclaredExceptions)
        #renderAltFlowTestsForDeclaredExceptions($method, $macro.allSourceMethodExceptions)
    #end
#end

##----------------------------------------------------------------------------------------------------------------------
## renderAltFlowTestsForDeclaredExceptions $method, $exceptions)
## Renders alt-flow tests where the provided $method is expected to throw the provided $exceptions.
## Param: $method - the method for which to render alt-flow tests.
##----------------------------------------------------------------------------------------------------------------------
#macro(renderAltFlowTestsForDeclaredExceptions $method, $exceptions)
    #set($macro.mockedDIs = $method.dependencyInteractions.satisfiedBy($dependencies.filter('shouldBeMocked')))
    #foreach($declaredException in $exceptions)
        #renderTestMethod($TestInfo.fromExpectedException($method, $macro.mockedDIs, $declaredException))
    #end
#end

##----------------------------------------------------------------------------------------------------------------------
## renderTestMethod($testInfo)
## Renders the test for the given Method.
## Param: $testInfo - information about which case this test should cover.
##----------------------------------------------------------------------------------------------------------------------
#macro(renderTestMethod $testInfo)
    #set($_ = $CodeStyleUtils.beginMethodScope())
    #if($sourceClass.enum)
        #renderTestMethodForEnum($testInfo)
    #elseif($sourceClass.packageVisibleStaticCreatorMethods.contains($testInfo.method) && !$sourceClass.singleton && !$testInfo.expectedException && !$testInfo.paramWithEmptyIo && !$testInfo.paramWithBrokenIo)
        #renderStaticCreatorMethodPrimaryFlowTest($testInfo)
    #else
        ## Determine if we should create an assertEquals(...) call.
        #set($macro.returnTypeIsArrayWithComparableType = $testInfo.method.returnType.array && ($testInfo.method.returnType.deepArrayComponentType.primitive || $testInfo.method.returnType.deepArrayComponentType.overridesEquals))
        #set($macro.shouldCreateAssertEqualsCall =
            $testInfo.method.returnType && ($testInfo.method.returnType.primitive || $testInfo.method.returnType.overridesEquals || $testInfo.method.returnType.array || $testInfo.expectedValueNull)
        && ($testInfo.method.returnType.classT || $testInfo.method.returnType.allNestedTypeParamsOverrideEquals || $testInfo.expectedValueEmpty || $testInfo.expectedValueAbsent || $macro.returnTypeIsArrayWithComparableType)
        && !$testInfo.expectedException)
        #set($macro.shouldStoreExpectedValue = $macro.shouldCreateAssertEqualsCall && !$testInfo.method.returnType.simple && !$testInfo.expectedValueEmpty && !$testInfo.expectedValueAbsent)
        ## Determine the test case suffix to use for this test method and store the result in: $testCaseSuffix.
        #determineTestCaseSuffix($testInfo)

    @Test
    public void test${StringUtils.capitalize(${testInfo.method.name})}${testInfo.method.overloadSuffix}${testCaseSuffix}() throws Exception {
            // Setup
        ## Declare parameters to use to invoke the method.
        #foreach($param in $testInfo.method.parameters.filter('shouldStoreInReference', true))
            #if($param == $testInfo.paramWithEmptyIo)
                #declareAndInitLocalVarImpl($param, $param.type.emptyIoInitExpression, true)
            #elseif($param == $testInfo.paramWithBrokenIo)
                #declareAndInitLocalVarImpl($param, $param.type.brokenIoInitExpression, true)
            #else
                #declareAndInitLocalVar($param, true)
            #end
        #end
        #if($macro.shouldStoreExpectedValue)
            #declareAndInitLocalVar($testInfo.method.returnType, true)
        #end
        #renderStubs($testInfo)

            // Run the test
        #set($macro.qualifier = "#if($testInfo.method.static)${sourceClass.canonicalNameOrName}#else${sourceClass.testClassMemberName}#end")
            String uri = 自行拼接;
        #if($testInfo.method.hasAnnotation("PostMapping"))
                // 请求的方式是post
                MockHttpServletRequestBuilder requestBuilder = MockMvcRequestBuilders.post(this.prefix + uri).contentType(MediaType.APPLICATION_JSON).content(JSONObject.toJSONString(需转化object));
                MvcResult mvcResult = mockMvc.perform(requestBuilder).andExpect(status().isOk()).andReturn();
        #elseif($testInfo.method.hasAnnotation("GetMapping"))
                // 请求的方式是get
                MockHttpServletRequestBuilder requestBuilder = MockMvcRequestBuilders.get(this.prefix + uri);
                MvcResult mvcResult = mockMvc.perform(requestBuilder).andExpect(status().isOk()).andReturn();
        #elseif($testInfo.method.hasAnnotation("DeleteMapping"))
                // 请求的方式是delete
                MockHttpServletRequestBuilder requestBuilder = MockMvcRequestBuilders.delete(this.prefix + uri);
                MvcResult mvcResult = mockMvc.perform(requestBuilder).andExpect(status().isOk()).andReturn();
        #elseif($testInfo.method.hasAnnotation("PutMapping"))
                // 请求的方式是put
                MockHttpServletRequestBuilder requestBuilder = MockMvcRequestBuilders.put(this.prefix + uri).contentType(MediaType.APPLICATION_JSON).content(JSONObject.toJSONString(需转化object));
                MvcResult mvcResult = mockMvc.perform(requestBuilder).andExpect(status().isOk()).andReturn();
        #end

        #if($testInfo.expectedException)
                assertThatThrownBy(() -> ${macro.qualifier}.#methodCall($testInfo.method, false)).isInstanceOf(${testInfo.expectedException.type.canonicalNameOrName}.class);
        #else
            #if($testInfo.method.returnType) final $testInfo.method.returnType.canonicalText result = #end ${macro.qualifier}.#methodCall($testInfo.method, false);

                // Verify the results
            #if($macro.shouldCreateAssertEqualsCall)
                #if($testInfo.expectedValueNull)
                        assertThat(result).isNull();
                #elseif($testInfo.expectedValueTrue)
                        assertThat(result).isTrue();
                #elseif($testInfo.expectedValueAbsent && $StringUtils.equalsAny($testInfo.method.returnType.canonicalName, 'java.util.Optional', 'java.util.OptionalLong', 'java.util.OptionalInt', 'java.util.OptionalDouble'))
                        assertThat(result).isEmpty();
                #else
                    #set($macro.expectedValueExpression = "#if($macro.shouldStoreExpectedValue)$testInfo.method.returnType.testClassLocalFieldName #elseif($testInfo.expectedValueEmpty)$testInfo.method.returnType.emptyInitExpression #elseif($testInfo.expectedValueAbsent)$testInfo.method.returnType.absentInitExpression #else $testInfo.method.returnType.initExpression #end")
                    #assertEqualsCall($macro.expectedValueExpression, 'result', $testInfo.method.returnType);
                #end
            #end
        #end
        #renderVerifyStatements($testInfo)
            }
    #end
    #set($_ = $CodeStyleUtils.endMethodScope())
#end

##----------------------------------------------------------------------------------------------------------------------
## renderStaticCreatorMethodPrimaryFlowTest($testInfo)
## Renders the primary flow test case for the given static method that returns an instance of the SourceClass.
## This test case calls methods on the returned source class to ensure it was created properly by the static method.
## Param: $testInfo - information about which case this test should cover.
##----------------------------------------------------------------------------------------------------------------------
#macro(renderStaticCreatorMethodPrimaryFlowTest $testInfo)
    #set($macro.shouldRenderSetup = $testInfo.method.parameters.containsAnyWith('shouldStoreInReference', true))
@Test
public void test${StringUtils.capitalize(${testInfo.method.name})}${testInfo.method.overloadSuffix}() throws Exception {
    #if($macro.shouldRenderSetup)
    // Setup
        ## Declare parameters to use to invoke the method.
        #foreach($param in $testInfo.method.parameters.filter('shouldStoreInReference', true))
            #declareAndInitLocalVar($param, true)
        #end

    #end
// Run the test
final $testInfo.method.returnType.canonicalText $testInfo.method.returnType.testClassLocalFieldName = ${sourceClass.canonicalNameOrName}.#methodCall($testInfo.method, false);
    #set($macro.instanceMethodsToCall = $sourceClass.allNonObjectLowestOverrideMethods.filterOut('static').filter('accessLevel', 'public', 'packagePrivate').filterOut('returnType', $Null).filterOut('simpleSetter').filterOutItemsWithRegex('name', '^(set|with|update)[A-Z0-9_]+.*'))
    #foreach($instanceMethod in $macro.instanceMethodsToCall)
        #foreach($param in $instanceMethod.parameters.filter('shouldStoreInReference', true))
            #declareAndInitLocalVar($param, true)
        #end
        ## There is a bug in the Velocity engine where macro calls in set statements don't work correctly when the
        ## VM_PERM_INLINE_LOCAL setting is enabled. To work around this, define a VTL block containing the macro call, then
        ## evaluate the block and assign the result in a set statement.
        #define($__workaroundCallExpression) ${testInfo.method.returnType.testClassLocalFieldName}.#methodCall($instanceMethod, false) #end
        #set($macro.callExpression = "$__workaroundCallExpression")
        #assertEqualsCall($instanceMethod.returnType.initExpression, $macro.callExpression, $instanceMethod.returnType);
    #end
        }
#end

##----------------------------------------------------------------------------------------------------------------------
## assertEqualsCall($expected, $actual, $type)
## Renders the assertEquals method call appropriate for the given parameters.
## Param: $expected - the value to use for the expected argument of the assertEquals method call.
## Param: $actual - the value to use for the actual argument of the assertEquals method call.
## Param: $type - the Type of the arguments; this is used to determine which assertEquals method to call.
##----------------------------------------------------------------------------------------------------------------------
#macro(assertEqualsCall $expected, $actual, $type)
    #if($StringUtils.equalsAny($type.canonicalName, 'double', 'java.lang.Double')) assertThat($actual).isEqualTo($expected, within(0.0001)) #break
    #elseif($StringUtils.equalsAny($type.canonicalName, 'float', 'java.lang.Float')) assertThat($actual).isEqualTo($expected, within(0.0001f)) #break
    #elseif($StringUtils.equalsAny($type.canonicalName, 'boolean', 'java.lang.Boolean')) assertThat($actual).isFalse() #break
    #else assertThat($actual).isEqualTo($expected) #end
#end

##----------------------------------------------------------------------------------------------------------------------
## renderStubs($testInfo)
## Renders the stubs (when, doAnswer, doThrow, etc) for the given test case.
## Param: $testInfo - information about which case this test should cover.
##----------------------------------------------------------------------------------------------------------------------
#macro(renderStubs $testInfo)
    #if(!$generateStubsAndVerifyStatements)#break #end
    #foreach($di in $testInfo.mockedDIs)
        #if($testInfo.shouldReturnAbsent($di))
            #renderAbsentStub($di)
        #elseif($testInfo.shouldReturnEmpty($di))
            #renderEmptyStub($di)
        #elseif($testInfo.shouldReturnEmptyIo($di))
            #renderEmptyIoStub($di)
        #elseif($testInfo.shouldReturnBrokenIo($di))
            #renderBrokenIoStub($di)
        #elseif($testInfo.shouldThrowException($di))
            #renderExceptionStub($di, $testInfo.getExceptionToThrow($di))
        #elseif($testInfo.shouldReturnFailure($di))
            #renderFailureStub($di)
        #else
            #renderPrimaryFlowStub($di)
        #end
    #end
#end

##----------------------------------------------------------------------------------------------------------------------
## renderPrimaryFlowStubs($dis)
## Renders the primary flow stubs (when, doAnswer, etc) for the given dependency interactions.
## Param: $dis - the dependency interactions to render stubs for.
##----------------------------------------------------------------------------------------------------------------------
#macro(renderPrimaryFlowStubs $dis)
    #foreach($di in $dis)
        #renderPrimaryFlowStub($di)
    #end
#end

##----------------------------------------------------------------------------------------------------------------------
## renderPrimaryFlowStubs($di)
## Renders the primary flow stub (when, doAnswer, etc) for the given dependency interaction.
## Param: $di - the dependency interaction to render stubs for.
##----------------------------------------------------------------------------------------------------------------------
#macro(renderPrimaryFlowStub $di)
    #set($macro.sourceVar = $di.field.possibleSourceVariables.intersection($dependencies).first)
    #set($macro.qualifier = "#if($shouldSetPackageLocalFields)${sourceClass.testClassMemberName}.${macro.sourceVar.declaredName}#else $macro.sourceVar.testClassMemberName #end")
    #if($di.method.parameters.containsAnyWith('type.canonicalName', 'java.lang.Runnable'))
        #renderAnswerForRunnable($di)
    #elseif($di.method.parameters.containsAnyWith('type.canonicalName', 'java.util.concurrent.Callable'))
        #renderAnswerForCallable($di)
    #elseif($di.method.returnType)
        #set($macro.hasInnerWildcardType = $di.method.returnType.parameters.containsAnyWith('wildcard', true))
        ## Declare a local variable for the return type if needed.
        #if($di.method.returnType.shouldStoreInReference)

                // Configure ${di.field.type.name}.${di.method.name}(...).
            #declareAndInitLocalVar($di.method.returnType, false)
        #end
        #set($macro.returnTypeExpression = "#if($di.method.returnType.shouldStoreInReference)$di.method.returnType.testClassLocalFieldName#else $di.method.returnType.initExpression #end")
        #if($macro.hasInnerWildcardType)
            $doReturn($macro.returnTypeExpression).$when($macro.qualifier).#methodCall($di.method, false);
        #else
            $when($macro.qualifier.#methodCall($di.method, false)).$thenReturn($macro.returnTypeExpression);
        #end
        #if($di.method.returnType.shouldStoreInReference) $Newline #end
    #end
#end

##----------------------------------------------------------------------------------------------------------------------
## renderAnswerForRunnable($di)
## Renders the doAnswer(...) statement for the dependency interaction whose method takes in at least one Runnable.
## Param: $di - the dependency interaction to render the doAnswer(...) statement for.
##----------------------------------------------------------------------------------------------------------------------
#macro(renderAnswerForRunnable $di)
    #set($macro.sourceVar = $di.field.possibleSourceVariables.intersection($dependencies).first)
    #set($macro.qualifier = "#if($shouldSetPackageLocalFields)${sourceClass.testClassMemberName}.${macro.sourceVar.declaredName}#else $macro.sourceVar.testClassMemberName #end")
    #set($macro.indexOfRunnable = $di.method.parameters.indexOfAny('type.canonicalName', 'java.lang.Runnable'))
    $doAnswer(invocation -> {
        ((Runnable) invocation.getArguments()[$macro.indexOfRunnable]).run();
    #if($StringUtils.equalsAny($di.method.returnType.canonicalName, 'java.util.concurrent.Future', 'java.util.concurrent.CompletableFuture'))
            return CompletableFuture.completedFuture(null);
    #elseif($di.method.returnType.canonicalName == 'com.google.common.util.concurrent.ListenableFuture')
    final com.google.common.util.concurrent.SettableFuture settableFuture = com.google.common.util.concurrent.SettableFuture.create();
            settableFuture.set(null);
            return settableFuture;
    #elseif($di.method.returnType.canonicalName == 'java.util.concurrent.ScheduledFuture')
    final java.util.concurrent.ScheduledFuture<?> mockFuture = #mock('java.util.concurrent.ScheduledFuture.class');
        $doReturn(null).$when(mockFuture).get();
        $doReturn(true).$when(mockFuture).isDone();
            return mockFuture;
    #elseif($di.method.returnType)
            return $di.method.returnType.initExpression;
    #else
            return null;
    #end
        }).$when($macro.qualifier).#methodCall($di.method, false);
#end

##----------------------------------------------------------------------------------------------------------------------
## renderAnswerForCallable($di)
## Renders the doAnswer(...) statement for the dependency interaction whose method takes in at least one Callable.
## Param: $di - the dependency interaction to render the doAnswer(...) statement for.
##----------------------------------------------------------------------------------------------------------------------
#macro(renderAnswerForCallable $di)
    #set($macro.sourceVar = $di.field.possibleSourceVariables.intersection($dependencies).first)
    #set($macro.qualifier = "#if($shouldSetPackageLocalFields)${sourceClass.testClassMemberName}.${macro.sourceVar.declaredName}#else $macro.sourceVar.testClassMemberName #end")
    #set($macro.indexOfCallable = $di.method.parameters.indexOfAny('type.canonicalName', 'java.util.concurrent.Callable'))
    $doAnswer(invocation -> {
final Callable<?> callable = (Callable<?>) invocation.getArguments()[$macro.indexOfCallable];
    #if($StringUtils.equalsAny($di.method.returnType.canonicalName, 'java.util.concurrent.Future', 'java.util.concurrent.CompletableFuture'))
            return CompletableFuture.completedFuture(callable.call());
    #elseif($di.method.returnType.canonicalName == 'com.google.common.util.concurrent.ListenableFuture')
    final com.google.common.util.concurrent.SettableFuture settableFuture = com.google.common.util.concurrent.SettableFuture.create();
            settableFuture.set(callable.call());
            return settableFuture;
    #elseif($di.method.returnType.canonicalName == 'java.util.concurrent.ScheduledFuture')
    final java.util.concurrent.ScheduledFuture<?> mockFuture = #mock('java.util.concurrent.ScheduledFuture.class');
        $doReturn(callable.call()).$when(mockFuture).get();
        $doReturn(true).$when(mockFuture).isDone();
            return mockFuture;
    #elseif($di.method.returnType)
            return $di.method.returnType.initExpression;
    #else
            return null;
    #end
        }).$when($macro.qualifier).#methodCall($di.method, false);
#end

##----------------------------------------------------------------------------------------------------------------------
## renderExceptionStub($di, $exceptionToThrow)
## Configures the provided dependency interaction ($di) to throw the provided $exceptionToThrow.
## Param: $di - the dependency interaction to be configured to throw.
## Param: $exceptionToThrow - the exception the $di should throw.
##----------------------------------------------------------------------------------------------------------------------
#macro(renderExceptionStub $di, $exceptionToThrow)
    #set($macro.sourceVar = $di.field.possibleSourceVariables.intersection($dependencies).first)
    #set($macro.qualifier = "#if($shouldSetPackageLocalFields)${sourceClass.testClassMemberName}.${macro.sourceVar.declaredName}#else $macro.sourceVar.testClassMemberName #end")
    #if($di.method.returnType)
        $when($macro.qualifier.#methodCall($di.method, false)).$thenThrow(${exceptionToThrow.type.canonicalNameOrName}.class);
    #else
        $doThrow(${exceptionToThrow.type.canonicalNameOrName}.class).$when($macro.qualifier).#methodCall($di.method, false);
    #end
#end

##----------------------------------------------------------------------------------------------------------------------
## renderAbsentStub($di)
## Configures the provided dependency interaction ($di) to return either null or an absent value.
## Param: $di - the dependency interaction to be configured to return an absent value.
##----------------------------------------------------------------------------------------------------------------------
#macro(renderAbsentStub $di)
    #set($macro.sourceVar = $di.field.possibleSourceVariables.intersection($dependencies).first)
    #set($macro.qualifier = "#if($shouldSetPackageLocalFields)${sourceClass.testClassMemberName}.${macro.sourceVar.declaredName}#else $macro.sourceVar.testClassMemberName #end")
    #set($macro.hasInnerWildcardType = $di.method.returnType.parameters.containsAnyWith('wildcard', true))
    #set($macro.isListenableFuture = $ListenableFutureNames.contains($di.method.returnType.canonicalName))
    #set($macro.shouldStoreInReference = !$di.method.inferredNullable && ($macro.isListenableFuture || $di.method.returnType.shouldBeSpied))
    #if($macro.shouldStoreInReference)

            // Configure ${di.field.type.name}.${di.method.name}(...).
        #if($macro.isListenableFuture)
            #declareAndInitListenableFuture($di.method.returnType, $di.method.returnType.parameters.first.absentInitExpression)
        #elseif($di.method.returnType.shouldBeSpied)
            #declareAndInitLocalVarImpl($di.method.returnType, $di.method.returnType.absentInitExpression, false)
        #end
    #end
    #set($macro.returnTypeExpression = "#if($macro.shouldStoreInReference)$di.method.returnType.testClassLocalFieldName#else $di.method.returnType.absentInitExpression #end")
    #if($macro.hasInnerWildcardType)
        $doReturn($macro.returnTypeExpression).$when($macro.qualifier).#methodCall($di.method, false);
    #else
        $when($macro.qualifier.#methodCall($di.method, false)).$thenReturn($macro.returnTypeExpression);
    #end
    #if($macro.shouldStoreInReference) $Newline #end
#end

##----------------------------------------------------------------------------------------------------------------------
## renderEmptyIoStub($di)
## Configures the provided dependency interaction ($di) to return either null or an absent value.
## Param: $di - the dependency interaction to be configured to return an absent value.
##----------------------------------------------------------------------------------------------------------------------
#macro(renderEmptyIoStub $di)
    #set($macro.sourceVar = $di.field.possibleSourceVariables.intersection($dependencies).first)
    #set($macro.qualifier = "#if($shouldSetPackageLocalFields)${sourceClass.testClassMemberName}.${macro.sourceVar.declaredName}#else $macro.sourceVar.testClassMemberName #end")
    #set($macro.hasInnerWildcardType = $di.method.returnType.parameters.containsAnyWith('wildcard', true))
    #set($macro.isListenableFuture = $ListenableFutureNames.contains($di.method.returnType.canonicalName))
    #set($macro.shouldStoreInReference = true)
    #if($macro.shouldStoreInReference)

            // Configure ${di.field.type.name}.${di.method.name}(...).
        #if($macro.isListenableFuture)
            #declareAndInitListenableFuture($di.method.returnType, $di.method.returnType.parameters.first.emptyIoInitExpression)
        #elseif($di.method.returnType.dtoBeanWithInputIoProperty)
            #declareAndInitLocalVarBeanWithAltIo($di.method.returnType, true, false, false)
        #else
            #declareAndInitLocalVarImpl($di.method.returnType, $di.method.returnType.emptyIoInitExpression, false)
        #end
    #end
    #set($macro.returnTypeExpression = "#if($macro.shouldStoreInReference)$di.method.returnType.testClassLocalFieldName#else $di.method.returnType.emptyIoInitExpression #end")
    #if($macro.hasInnerWildcardType)
        $doReturn($macro.returnTypeExpression).$when($macro.qualifier).#methodCall($di.method, false);
    #else
        $when($macro.qualifier.#methodCall($di.method, false)).$thenReturn($macro.returnTypeExpression);
    #end
    #if($macro.shouldStoreInReference) $Newline #end
#end

##----------------------------------------------------------------------------------------------------------------------
## renderBrokenIoStub($di)
## Configures the provided dependency interaction ($di) to return either null or an absent value.
## Param: $di - the dependency interaction to be configured to return an absent value.
##----------------------------------------------------------------------------------------------------------------------
#macro(renderBrokenIoStub $di)
    #set($macro.sourceVar = $di.field.possibleSourceVariables.intersection($dependencies).first)
    #set($macro.qualifier = "#if($shouldSetPackageLocalFields)${sourceClass.testClassMemberName}.${macro.sourceVar.declaredName}#else $macro.sourceVar.testClassMemberName #end")
    #set($macro.hasInnerWildcardType = $di.method.returnType.parameters.containsAnyWith('wildcard', true))
    #set($macro.isListenableFuture = $ListenableFutureNames.contains($di.method.returnType.canonicalName))
    #set($macro.shouldStoreInReference = true)
    #if($macro.shouldStoreInReference)

            // Configure ${di.field.type.name}.${di.method.name}(...).
        #if($macro.isListenableFuture)
            #declareAndInitListenableFuture($di.method.returnType, $di.method.returnType.parameters.first.brokenIoInitExpression)
        #elseif($di.method.returnType.dtoBeanWithInputIoProperty)
            #declareAndInitLocalVarBeanWithAltIo($di.method.returnType, false, true, false)
        #else
            #declareAndInitLocalVarImpl($di.method.returnType, $di.method.returnType.brokenIoInitExpression, false)
        #end
    #end
    #set($macro.returnTypeExpression = "#if($macro.shouldStoreInReference)$di.method.returnType.testClassLocalFieldName#else $di.method.returnType.brokenIoInitExpression #end")
    #if($macro.hasInnerWildcardType)
        $doReturn($macro.returnTypeExpression).$when($macro.qualifier).#methodCall($di.method, false);
    #else
        $when($macro.qualifier.#methodCall($di.method, false)).$thenReturn($macro.returnTypeExpression);
    #end
    #if($macro.shouldStoreInReference) $Newline #end
#end

##----------------------------------------------------------------------------------------------------------------------
## renderEmptyStub($di)
## Configures the provided dependency interaction ($di) to return an empty value.
## Param: $di - the dependency interaction to be configured to return an empty value.
##----------------------------------------------------------------------------------------------------------------------
#macro(renderEmptyStub $di)
    #set($macro.sourceVar = $di.field.possibleSourceVariables.intersection($dependencies).first)
    #set($macro.qualifier = "#if($shouldSetPackageLocalFields)${sourceClass.testClassMemberName}.${macro.sourceVar.declaredName}#else $macro.sourceVar.testClassMemberName #end")
    #set($macro.hasInnerWildcardType = $di.method.returnType.parameters.containsAnyWith('wildcard', true))
    #set($macro.isListenableFuture = $ListenableFutureNames.contains($di.method.returnType.canonicalName))
    #set($macro.emptyInitExpressionIsLong = $di.method.returnType.emptyInitExpression && $ClassUtils.removePackageQualifiers($di.method.returnType.emptyInitExpression).length() > 40)
    #set($macro.shouldStoreInReference = ($di.method.returnType.shouldStoreInReference && ($di.method.returnType.shouldBeMocked || $macro.emptyInitExpressionIsLong)) || $di.method.returnType.shouldBeSpied || $macro.isListenableFuture)
    #if($macro.shouldStoreInReference)

            // Configure ${di.field.type.name}.${di.method.name}(...).
        #if($macro.isListenableFuture)
            #declareAndInitListenableFuture($di.method.returnType, $di.method.returnType.parameters.first.emptyInitExpression)
        #elseif($di.method.returnType.shouldBeSpied || $macro.emptyInitExpressionIsLong)
            #declareAndInitLocalVarImpl($di.method.returnType, $di.method.returnType.emptyInitExpression, false)
        #else
            #declareAndInitLocalVar($di.method.returnType, false)
        #end
    #end
    #set($macro.returnTypeExpression = "#if($macro.shouldStoreInReference)$di.method.returnType.testClassLocalFieldName#else $di.method.returnType.emptyInitExpression #end")
    #if($macro.hasInnerWildcardType)
        $doReturn($macro.returnTypeExpression).$when($macro.qualifier).#methodCall($di.method, false);
    #else
        $when($macro.qualifier.#methodCall($di.method, false)).$thenReturn($macro.returnTypeExpression);
    #end
    #if($macro.shouldStoreInReference) $Newline #end
#end

##----------------------------------------------------------------------------------------------------------------------
## renderFailureStub($di)
## Configures the provided dependency interaction ($di) to return an empty value.
## Param: $di - the dependency interaction to be configured to return an empty value.
##----------------------------------------------------------------------------------------------------------------------
#macro(renderFailureStub $di)
    #set($macro.sourceVar = $di.field.possibleSourceVariables.intersection($dependencies).first)
    #set($macro.qualifier = "#if($shouldSetPackageLocalFields)${sourceClass.testClassMemberName}.${macro.sourceVar.declaredName}#else $macro.sourceVar.testClassMemberName #end")
    #set($macro.hasInnerWildcardType = $di.method.returnType.parameters.containsAnyWith('wildcard', true))
    #set($macro.isListenableFuture = $ListenableFutureNames.contains($di.method.returnType.canonicalName))
    #set($macro.isStandardFuture = $StringUtils.equalsAny($di.method.returnType.canonicalName, 'java.util.concurrent.Future', 'java.util.concurrent.CompletableFuture', 'java.util.concurrent.CompletionStage'))
    #set($macro.shouldStoreInReference = $di.method.returnType.shouldStoreInReference || $di.method.returnType.shouldBeSpied || $macro.isListenableFuture || ($macro.isStandardFuture && !$di.method.returnType.failureInitExpression))
    #if($macro.shouldStoreInReference)

            // Configure ${di.field.type.name}.${di.method.name}(...).
        #if($macro.isListenableFuture)
            #declareAndInitListenableFutureFailureCase($di.method.returnType)
        #elseif($macro.isStandardFuture && !$di.method.returnType.failureInitExpression)
            #declareAndInitCompletableFutureFailureCase($di.method.returnType)
        #else
            #declareAndInitLocalVarImpl($di.method.returnType, $di.method.returnType.failureInitExpression, false)
        #end
    #end
    #set($macro.returnTypeExpression = "#if($macro.shouldStoreInReference)$di.method.returnType.testClassLocalFieldName#else $di.method.returnType.failureInitExpression #end")
    #if($macro.hasInnerWildcardType)
        $doReturn($macro.returnTypeExpression).$when($macro.qualifier).#methodCall($di.method, false);
    #else
        $when($macro.qualifier.#methodCall($di.method, false)).$thenReturn($macro.returnTypeExpression);
    #end
    #if($macro.shouldStoreInReference) $Newline #end
#end

##----------------------------------------------------------------------------------------------------------------------
## declareAndInitLocalVar($param, $addNewlineAfterBean)
## Declares and initializes a local variable for $param. If $param is a DTOBean, Squaretest will initialize its
## properties. Squaretest also initializes any DTOBeans required for the $param's initialization expression.
## Param: $param               - the Type or Variable to declare and initialize.
## Param: $addNewlineAfterBean - boolean indicating whether a newline should be added after bean init code (or false).
##----------------------------------------------------------------------------------------------------------------------
#macro(declareAndInitLocalVar $param, $addNewlineAfterBean = false)
    #if($ListenableFutureNames.contains($param.type.canonicalName))
        #declareAndInitListenableFuture($param, false)
    #else
        #declareAndInitLocalVarImpl($param, false, $addNewlineAfterBean)
    #end
#end

##----------------------------------------------------------------------------------------------------------------------
## declareAndInitLocalVarImpl($param, $addNewlineAfterBean)
## The implementation for declareAndInitLocalVar(..).
## Param: $param - the Type or Variable to declare and initialize.
## Param: $initExpressionToUse (optional) - The init expression to use inline for the $param (or false).
## Param: $addNewlineAfterBean - boolean indicating whether a newline should be added after bean init code (or false).
##----------------------------------------------------------------------------------------------------------------------
#macro(declareAndInitLocalVarImpl $param, $initExpressionToUse = false, $addNewlineAfterBean = false)
    #set($macro.isOrHasBean = $param.type.dtoBean || !$param.type.initExpressionBeans.empty)
    #set($_ = $CodeStyleUtils.updateLocalFieldNameWithMethodScope($param))
    #if($initExpressionToUse)
    final $param.type.canonicalText $param.testClassLocalFieldName = $initExpressionToUse;
    #elseif($param.type.dtoBean)
    final $param.type.canonicalText $param.testClassLocalFieldName = $param.type.initExpression;
        #renderBeanSetupCodeForVar($param, false, false)
        #if($addNewlineAfterBean) $Newline #end
    #elseif(!$param.type.initExpressionBeans.empty)
        ## The parameter's initExpression has one or more beans; e.g. the bean in Optional.of(bean).
        ## Declare and init the beans first.
        #foreach($beanType in $param.type.initExpressionBeans)
            ## Declare the local field for the bean and initialize it.
            #declareAndInitLocalVar($beanType, false)
        #end
        #set($param.type.initExpression = $param.type.createInitExpressionWithLocalFieldBeans($param.type.initExpressionBeans))
    final $param.type.canonicalText $param.testClassLocalFieldName = $param.type.initExpression;
    #else
    final $param.type.canonicalText $param.testClassLocalFieldName = $param.type.initExpression;
    #end
#end

##----------------------------------------------------------------------------------------------------------------------
## declareAndInitLocalVarBeanWithAltIo($param, $shouldUseEmptyIo, $shouldUseBrokenIo, $addNewlineAfterBean)
## Declares and initializes a bean using an alternate IO init expression for its IO property.
## Param: $param             - the Type or Variable to declare and initialize.
## Param: $shouldUseEmptyIo  - boolean indicating whether or not to initialize the IO property to the empty IO variant.
## Param: $shouldUseBrokenIo - boolean indicating whether or not to initialize the IO property to the broken IO variant.
## Param: $addNewlineAfterBean - boolean indicating whether a newline should be added after bean init code (or false).
##----------------------------------------------------------------------------------------------------------------------
#macro(declareAndInitLocalVarBeanWithAltIo $param, $shouldUseEmptyIo, $shouldUseBrokenIo, $addNewlineAfterBean = false)
    #set($_ = $CodeStyleUtils.updateLocalFieldNameWithMethodScope($param))
final $param.type.canonicalText $param.testClassLocalFieldName = $param.type.initExpression;
    #renderBeanSetupCodeForVar($param, $shouldUseEmptyIo, $shouldUseBrokenIo)
    #if($addNewlineAfterBean) $Newline #end
#end

##----------------------------------------------------------------------------------------------------------------------
## declareAndInitListenableFuture($param, $innerTypeInitExpression)
## Declares and initializes a ListenableFuture or SettableFuture.
## Param: $param                               - the Type or Variable to declare and initialize.
## Param: $innerTypeInitExpression (optional)  - The init expression to use for the Future's type parameter (or false).
##----------------------------------------------------------------------------------------------------------------------
#macro(declareAndInitListenableFuture $param, $innerTypeInitExpression = false)
    #set($_ = $CodeStyleUtils.updateLocalFieldNameWithMethodScope($param))
    #set($macro.shouldSetInnerType = $innerTypeInitExpression || !$param.type.parameters.first.canonicalText.equals('?'))
    #set($macro.shouldStoreInnerTypeInVar = !$innerTypeInitExpression && $macro.shouldSetInnerType && !$param.type.parameters.first.simple)
    #set($macro.settableFutureInfo = $ListenableFutureToSettableFutureMap.get("$param.type.canonicalName"))
    #if($macro.shouldStoreInnerTypeInVar)
        #declareAndInitLocalVar($param.type.parameters.first, false)
    #end
final $macro.settableFutureInfo[0]<$param.type.parameters.first.canonicalText> $param.testClassLocalFieldName = $macro.settableFutureInfo[1];
    #if($macro.shouldSetInnerType)
        #if($innerTypeInitExpression)
            ${param.testClassLocalFieldName}.set($innerTypeInitExpression);
        #elseif($macro.shouldStoreInnerTypeInVar)
            ${param.testClassLocalFieldName}.set($param.type.parameters.first.testClassLocalFieldName);
        #else
            ${param.testClassLocalFieldName}.set($param.type.parameters.first.initExpression);
        #end
    #end
#end

##----------------------------------------------------------------------------------------------------------------------
## declareAndInitListenableFutureFailureCase($param)
## Declares and initializes a ListenableFuture or SettableFuture with an Exception result.
## Param: $param - the Type or Variable to declare and initialize.
##----------------------------------------------------------------------------------------------------------------------
#macro(declareAndInitListenableFutureFailureCase $param)
    #set($_ = $CodeStyleUtils.updateLocalFieldNameWithMethodScope($param))
    #set($macro.settableFutureInfo = $ListenableFutureToSettableFutureMap.get("$param.type.canonicalName"))
final $macro.settableFutureInfo[0]<$param.type.parameters.first.canonicalText> $param.testClassLocalFieldName = $macro.settableFutureInfo[1];
    ${param.testClassLocalFieldName}.setException(new java.lang.Exception("message"));
#end

##----------------------------------------------------------------------------------------------------------------------
## declareAndInitCompletableFutureFailureCase($param)
## Declares and initializes a Future or CompletableFuture with an Exception result. This is needed to support Java 8.
## In Java 9+ CompletableFuture.failedFuture(exception) is used to construct the future with an exception result.
## Param: $param - the Type or Variable to declare and initialize.
##----------------------------------------------------------------------------------------------------------------------
#macro(declareAndInitCompletableFutureFailureCase $param)
    #set($_ = $CodeStyleUtils.updateLocalFieldNameWithMethodScope($param))
final java.util.concurrent.CompletableFuture<$param.type.parameters.first.canonicalText> $param.testClassLocalFieldName = new java.util.concurrent.CompletableFuture<>();
    ${param.testClassLocalFieldName}.completeExceptionally(new java.lang.Exception("message"));
#end

##----------------------------------------------------------------------------------------------------------------------
## renderBeanSetupCodeForVar($param, $shouldUseEmptyIo, $shouldUseBrokenIo)
## Renders the code necessary to configure the provided bean.
## Param: $param - the Type or Variable for which to render the bean setup code.
## Param: $shouldUseEmptyIo  - boolean indicating whether or not to initialize the IO property to the empty IO variant.
## Param: $shouldUseBrokenIo - boolean indicating whether or not to initialize the IO property to the broken IO variant.
##----------------------------------------------------------------------------------------------------------------------
#macro(renderBeanSetupCodeForVar $param, $shouldUseEmptyIo, $shouldUseBrokenIo)
    #set($macro.canonicalNamesInCallStack = {})
    #set($macro.canonicalNamesInCallStack[$param.type.canonicalName] = true)
    #set($macro.numberOfSettersCalled = $MutableInt.create(0))
    #renderBeanSetupCodeRecursively($param, $BeanContext.create($param, $minNumberOfSettersToCall, $maxNumberOfSettersToCall), $shouldUseEmptyIo, $shouldUseBrokenIo, $macro.canonicalNamesInCallStack, $macro.numberOfSettersCalled)
#end

##----------------------------------------------------------------------------------------------------------------------
## renderBeanSetupCodeRecursively(..)
## This should only be called from the #renderBeanSetupCodeForVar() macro.
## Renders the code necessary to configure the provided bean and its properties that are beans or lists of beans.
## Param: $typeOrVariable         - the Type or Variable for which to render the bean setup code.
## Param: $beanContext            - the context describing how to initialize the top level bean and its sub beans.
## Param: $shouldUseEmptyIo  - boolean indicating whether or not to initialize the IO property to the empty IO variant.
## Param: $shouldUseBrokenIo - boolean indicating whether or not to initialize the IO property to the broken IO variant.
## Param: $canonicalNamesInCallStack - the canonical names of beans in the recursive init call stack. This is used to
##        avoid infinite recursive loops.
## Param: $numberOfSettersCalled     - MutableInt containing the total number of setters called in this recurisve call.
##----------------------------------------------------------------------------------------------------------------------
#macro(renderBeanSetupCodeRecursively $typeOrVariable, $beanContext, $shouldUseEmptyIo, $shouldUseBrokenIo, $canonicalNamesInCallStack, $numberOfSettersCalled)
    #set($macro.beanClass = $ClassUtils.resolveBean($beanContext, $typeOrVariable))
    #if(!$macro.beanClass)#break #end
    #set($macro.beanClass.testClassLocalFieldName = $typeOrVariable.testClassLocalFieldName)
    #set($macro.preferredSetters = $macro.beanClass.preferredInitMethods)
    #foreach($setter in $macro.preferredSetters)
        #if($numberOfSettersCalled.intValue() >= $beanContext.maxSettersToCall)#break #end
        #set($_ = $numberOfSettersCalled.increment())
        #if($setter.jaxbListGetter)
            #set($macro.param = $setter.returnType)
        #else
            #set($macro.param = $setter.parameters.first)
        #end
        #if($macro.param.type.generic && $typeOrVariable.type.parameters.size() == 1 && !$typeOrVariable.type.parameters.first.generic)
            #set($macro.param = $typeOrVariable.type.parameters.first)
        #end
        #if($macro.param.type.dtoBean)
            #if(!$canonicalNamesInCallStack[$macro.param.type.canonicalName])
                #set($_ = $CodeStyleUtils.updateLocalFieldNameWithMethodScope($macro.param))
            final $macro.param.type.canonicalText $macro.param.testClassLocalFieldName = $macro.param.initExpression;
                ## Store the beans cannonical name in map to avoid entering a recursive loop.
                #set($canonicalNamesInCallStack[$macro.param.type.canonicalName] = true)
                #renderBeanSetupCodeRecursively($macro.param, $beanContext, false, false, $canonicalNamesInCallStack, $numberOfSettersCalled)
                #set($canonicalNamesInCallStack[$macro.param.type.canonicalName] = false)
                #set($macro.param.shouldStoreInReference = true)
            #else
                #set($macro.param.shouldStoreInReference = false)
            #end
        #elseif(!$macro.param.type.initExpressionBeans.empty)
            ## The setter's param's initExpression contains at least one bean.
            #foreach($beanType in $macro.param.type.initExpressionBeans)
                #if(!$canonicalNamesInCallStack[$beanType.canonicalName])
                    #set($_ = $CodeStyleUtils.updateLocalFieldNameWithMethodScope($beanType))
                final $beanType.canonicalText $beanType.testClassLocalFieldName = $beanType.initExpression;
                    #set($canonicalNamesInCallStack[$beanType.canonicalName] = true)
                    #renderBeanSetupCodeRecursively($beanType, $beanContext, false, false, $canonicalNamesInCallStack, $numberOfSettersCalled)
                    #set($canonicalNamesInCallStack[$beanType.canonicalName] = false)
                    #set($beanType.shouldStoreInReference = true)
                #else
                    #set($beanType.shouldStoreInReference = false)
                #end
            #end
            #set($macro.param.type.initExpression = $macro.param.type.createInitExpressionWithLocalFieldBeans($macro.param.type.initExpressionBeans.filter('shouldStoreInReference')))
            #set($macro.param.shouldStoreInReference = false)
        #else
            #set($macro.param.shouldStoreInReference = false)
        #end
        #if($setter.jaxbListGetter)
            ${macro.beanClass.testClassLocalFieldName}.${setter.name}().addAll($macro.param.type.initExpression);
        #elseif($shouldUseEmptyIo && $macro.param.type.emptyIoInitExpression)
            ${macro.beanClass.testClassLocalFieldName}.${setter.name}($macro.param.type.emptyIoInitExpression);
        #elseif($shouldUseBrokenIo && $macro.param.type.brokenIoInitExpression)
            ${macro.beanClass.testClassLocalFieldName}.${setter.name}($macro.param.type.brokenIoInitExpression);
        #else
            #if($macro.param.shouldStoreInReference)
                ${macro.beanClass.testClassLocalFieldName}.${setter.name}($macro.param.testClassLocalFieldName);
            #else
                ${macro.beanClass.testClassLocalFieldName}.${setter.name}($macro.param.type.initExpression);
            #end
        #end
    #end
    #renderExtraBeanSetupCode($macro.beanClass)
#end

##----------------------------------------------------------------------------------------------------------------------
## renderExtraBeanSetupCode($beanSourceClass)
## Renders any extra statements needed to initialize the instance of the $beanSourceClass.
## Param: $beanSourceClass - the SourceClass for the bean to render extra initialization code for.
##----------------------------------------------------------------------------------------------------------------------
#macro(renderExtraBeanSetupCode $beanSourceClass)
    #if($StringUtils.equalsAny($beanSourceClass.type.canonicalName, 'com.amazonaws.services.s3.model.PresignedUrlDownloadResult'))
    final com.amazonaws.services.s3.model.S3Object spyS3Object = spy(new com.amazonaws.services.s3.model.S3Object());
            spyS3Object.setBucketName("bucketName");
            spyS3Object.setKey("key");
            spyS3Object.setObjectContent(new java.io.ByteArrayInputStream("objectContent".getBytes()));
        ${beanSourceClass.testClassLocalFieldName}.setS3Object(spyS3Object);
    #end
#end

##----------------------------------------------------------------------------------------------------------------------
## renderVerifyStatements($testInfo)
## Renders verify statements for the given test case.
## Param: $testInfo - information about which case this test should cover.
##----------------------------------------------------------------------------------------------------------------------
#macro(renderVerifyStatements $testInfo)
    #if(!$generateStubsAndVerifyStatements)#break #end
    #foreach($di in $testInfo.mockedDIs)
        #if($testInfo.shouldReturnAbsent($di))
            #if($di.method.inferredNullable && $di.method.returnType.shouldBeSpied)
                ## Do nothing. The DI normally returns a closeable. It's returning null in this case, so no verify(..) is needed.
            #elseif($di.returnValueIgnored || $di.method.returnType.shouldBeSpied)
                #renderPrimaryFlowVerifyStatement($di)
            #end
        #elseif($testInfo.shouldReturnEmpty($di))
            #if($di.method.returnType.shouldBeSpied || $di.returnValueIgnored)
                #renderPrimaryFlowVerifyStatement($di)
            #end
        #elseif($testInfo.shouldReturnEmptyIo($di))
            #if($di.method.returnType.shouldBeSpied || $di.returnValueIgnored)
                #renderPrimaryFlowVerifyStatement($di)
            #end
        #elseif($testInfo.shouldReturnBrokenIo($di))
            #if($di.method.returnType.shouldBeSpied)
                #renderPrimaryFlowVerifyStatement($di)
            #end
        #elseif($testInfo.shouldThrowException($di))
            ## Do nothing.
        #elseif($testInfo.shouldReturnFailure($di))
            #if($di.returnValueIgnored || $di.method.returnType.closeable)
                #renderPrimaryFlowVerifyStatement($di)
            #end
        #else
            #renderPrimaryFlowVerifyStatement($di)
        #end
    #end
#end

##----------------------------------------------------------------------------------------------------------------------
## renderPrimaryFlowVerifyStatements($dis)
## Renders primary flow verify statements for the given dependency interactions ($dis).
## Param: $dis - the dependency interactions to render the primary flow verify statements for.
##----------------------------------------------------------------------------------------------------------------------
#macro(renderPrimaryFlowVerifyStatements $dis)
    #foreach($di in $dis)
        #renderPrimaryFlowVerifyStatement($di)
    #end
#end

##----------------------------------------------------------------------------------------------------------------------
## renderPrimaryFlowVerifyStatement($di)
## Renders primary flow verify statement for the given dependency interactions ($di).
## Param: $di - the dependency interactions to render the primary flow verify statement for.
##----------------------------------------------------------------------------------------------------------------------
#macro(renderPrimaryFlowVerifyStatement $di)
    #set($macro.sourceVar = $di.field.possibleSourceVariables.intersection($dependencies).first)
    #set($macro.qualifier = "#if($shouldSetPackageLocalFields)${sourceClass.testClassMemberName}.${macro.sourceVar.declaredName}#else $macro.sourceVar.testClassMemberName #end")
    #if(!$di.method.returnType)
        #if($shouldUseMockitoBdd)
                then($macro.qualifier).should().#methodCall($di.method, false);
        #else
                verify($macro.qualifier).#methodCall($di.method, false);
        #end
    #elseif($di.method.returnType.closeable && $di.method.returnType.shouldStoreInReference)
        #if($shouldUseMockitoBdd)
                then($di.method.returnType.testClassLocalFieldName).should().close();
        #else
                verify($di.method.returnType.testClassLocalFieldName).close();
        #end
    #elseif($di.returnValueIgnored)
        #if($shouldUseMockitoBdd)
                then($macro.qualifier).should().#methodCall($di.method, false);
        #else
                verify($macro.qualifier).#methodCall($di.method, false);
        #end
    #end
    #renderExtraVerifyStatements($di)
#end

##----------------------------------------------------------------------------------------------------------------------
## renderExtraVerifyStatements($di)
## Renders any extra verify statements needed for the provided dependency interaction.
## Param: $di - the dependency interactions to render the primary flow verify statement for.
##----------------------------------------------------------------------------------------------------------------------
#macro(renderExtraVerifyStatements $di)
    #if($StringUtils.equalsAny($di.method.returnType.canonicalName, 'com.amazonaws.services.s3.model.PresignedUrlDownloadResult'))
        #if($shouldUseMockitoBdd)
                then(spyS3Object).should().close();
        #else
                verify(spyS3Object).close();
        #end
    #end
#end

##----------------------------------------------------------------------------------------------------------------------
## methodCall($method, $assumeArgsAreStoredInMembers)
## Renders an expression to call the given method. This does not include any qualifiers required to reference
## the method.
## Param: $method - the method or constructor for which to render the call-expression.
## Param: $assumeArgsAreStoredInMembers (optional) - assumes the arguments are stored in member fields instead of
##        local fields.
## Note: This macro uses multiline comments: #* and *# to avoid adding newlines.
##----------------------------------------------------------------------------------------------------------------------
#macro(methodCall $method, $assumeArgsAreStoredInMembers = false)#*
    *#${method.name}#if($method.constructor && $sourceClass.hasGenerics)<>#end#*
    *#(#foreach($param in $method.parameters)#*
        *##if(!$param.shouldStoreInReference)#*
            *#$param.initExpression#*
        *##elseif($assumeArgsAreStoredInMembers)#*
            *#$param.testClassMemberName#*
        *##else#*
            *#$param.testClassLocalFieldName#*
        *##end#*
        *##if($foreach.hasNext),#end#*
    *##end)#*
*##end

##----------------------------------------------------------------------------------------------------------------------
## determineTestCaseSuffix($testInfo)
## Determines the suffix to use for the given test case and stores the result in $testCaseSuffix.
## Param: $testInfo - information about which case this test should cover.
## Out:   $testCaseSuffix - the suffix to use for this test case.
##----------------------------------------------------------------------------------------------------------------------
#macro(determineTestCaseSuffix $testInfo)
    #set($macro.disToUse = $testInfo.method.dependencyInteractions.satisfiedBy($dependencies.filter('shouldBeMocked')))
    #if($testInfo.subjectDi)
        #if($macro.disToUse.filterOutItemsWithSameSourceVar($testInfo.subjectDi).containsAnyWith('field.type.name', $testInfo.subjectDi.field.type.name))
            #set($macro.fieldName = "$StringUtils.capitalize($testInfo.subjectDi.field.declaredNameWithoutPrefix)")
        #else
            #set($macro.fieldName = "${testInfo.subjectDi.field.type.name}")
        #end
        #if($macro.disToUse.filterItemsWithSameSourceVar($testInfo.subjectDi).size() > 1)
            #set($macro.descriptionPart1 = "_${macro.fieldName}$StringUtils.capitalize($testInfo.subjectDi.method.name)")
        #else
            #set($macro.descriptionPart1 = "_${macro.fieldName}")
        #end
    #end
    #if($testInfo.paramWithEmptyIo)
        #set($testCaseSuffix = '_Empty' + $StringUtils.capitalize($testInfo.paramWithEmptyIo.declaredName))
    #elseif($testInfo.paramWithBrokenIo)
        #set($testCaseSuffix = '_Broken' + $StringUtils.capitalize($testInfo.paramWithBrokenIo.declaredName))
    #elseif($testInfo.subjectDiExceptionToThrow)
        #set($testCaseSuffix = "${macro.descriptionPart1}Throws${testInfo.subjectDiExceptionToThrow.type.name}")
    #elseif($testInfo.subjectDiReturnsFailure)
        #if($StringUtils.containsIgnoreCase($testInfo.subjectDi.method.returnType.failureInitExpression, 'Error'))
            #set($macro.returnSuffix = 'ReturnsError')
        #else
            #set($macro.returnSuffix = 'ReturnsFailure')
        #end
        #set($testCaseSuffix = "${macro.descriptionPart1}" + $macro.returnSuffix)
    #elseif($testInfo.subjectDiReturnsEmpty)
        #set($testCaseSuffix = "${macro.descriptionPart1}" + 'ReturnsNoItems')
    #elseif($testInfo.subjectDiReturnsEmptyIo)
        #set($testCaseSuffix = "${macro.descriptionPart1}" + 'ReturnsNoContent')
    #elseif($testInfo.subjectDiReturnsBrokenIo)
        #set($testCaseSuffix = "${macro.descriptionPart1}" + 'ReturnsBrokenIo')
    #elseif($testInfo.subjectDiReturnsAbsent)
        #if($testInfo.subjectDi.method.inferredNullable)
            #set($macro.returnSuffix = 'ReturnsNull')
        #elseif($testInfo.subjectDi.method.returnType.optional)
            #set($macro.returnSuffix = 'ReturnsAbsent')
        #else
            #set($macro.returnSuffix = 'ReturnsNoItem')
        #end
        #set($testCaseSuffix = "${macro.descriptionPart1}" + $macro.returnSuffix)
    #elseif($testInfo.expectedException)
        #set($testCaseSuffix = "_Throws${testInfo.expectedException.type.name}")
    #else
        #set($testCaseSuffix = '')
    #end
#end

##----------------------------------------------------------------------------------------------------------------------
## renderTestMethodForEnum($testInfo)
## Renders the enum test method for the given Method. This is similar to #renderTestMethod($method) but calls the
## method on each value in the enum and adds an assertEquals call for each result.
## Param: $testInfo - information about which case this test should cover.
##----------------------------------------------------------------------------------------------------------------------
#macro(renderTestMethodForEnum $testInfo)
    #set($macro.multipleValuesTest = $sourceClass.enumValues.size() > 1 && !$testInfo.method.static)
    #set($macro.paramsToStoreInFields = $testInfo.method.parameters.filter('shouldStoreInReference', true))
    #set($macro.shouldRenderSetup = $macro.paramsToStoreInFields.size() > 0 || ($testInfo.method.returnType && !$testInfo.expectedException))
    #determineTestCaseSuffix($testInfo)
    #set($macro.returnTypeIsArrayWithComparableType = $testInfo.method.returnType.array && ($testInfo.method.returnType.deepArrayComponentType.primitive || $testInfo.method.returnType.deepArrayComponentType.overridesEquals))
    #set($macro.shouldCreateAssertEqualsCall =
    !$macro.multipleValuesTest && $testInfo.method.returnType && ($testInfo.method.returnType.primitive || $testInfo.method.returnType.overridesEquals || $testInfo.method.returnType.array)
    && ($testInfo.method.returnType.classT || $testInfo.method.returnType.allNestedTypeParamsOverrideEquals || $macro.returnTypeIsArrayWithComparableType)
    && !$testInfo.expectedException)
    #set($macro.shouldStoreExpectedValue = $macro.shouldCreateAssertEqualsCall && !$testInfo.method.returnType.simple)
    #set($macro.shouldRenderSimpleMultivalueTest = $macro.multipleValuesTest && ($testInfo.method.returnType || $testInfo.expectedException))
    #if($macro.shouldRenderSimpleMultivalueTest)
        #renderSimpleMultivalueTestMethodForEnum($testInfo)
        #break($macro)
    #end
@Test
public void test${StringUtils.capitalize(${testInfo.method.name})}${testInfo.method.overloadSuffix}${testCaseSuffix}() throws Exception {
    #if($macro.shouldRenderSetup)
            // Setup
        ## Declare parameters to use to invoke the method.
        #foreach($param in $macro.paramsToStoreInFields)
            #if($param == $testInfo.paramWithEmptyIo)
                #declareAndInitLocalVarImpl($param, $param.type.emptyIoInitExpression, true)
            #elseif($param == $testInfo.paramWithBrokenIo)
                #declareAndInitLocalVarImpl($param, $param.type.brokenIoInitExpression, true)
            #else
                #declareAndInitLocalVar($param, true)
            #end
        #end
        #if($macro.shouldStoreExpectedValue)
            #declareAndInitLocalVar($testInfo.method.returnType, true)
        #end

    #end
        // Run the test
    #set($macro.qualifier = "#if($testInfo.method.static)${sourceClass.canonicalNameOrName}#else${sourceClass.canonicalNameOrName}.${sourceClass.enumFirstValue}#end")
    #if($testInfo.expectedException)
            assertThatThrownBy(() -> ${macro.qualifier}.#methodCall($testInfo.method, false)).isInstanceOf(${testInfo.expectedException.type.canonicalNameOrName}.class);
    #elseif($macro.multipleValuesTest)
        #foreach($enumValue in $sourceClass.enumValues)
            ${sourceClass.canonicalNameOrName}.${enumValue}.#methodCall($testInfo.method, false);
        #end
    #else
        #if($testInfo.method.returnType) final $testInfo.method.returnType.canonicalText result = #end ${macro.qualifier}.#methodCall($testInfo.method, false);
    #end
    #if(!$testInfo.expectedException)

            // Verify the results
        #if($macro.shouldCreateAssertEqualsCall)
            #set($macro.expectedValueExpression = "#if($macro.shouldStoreExpectedValue)$testInfo.method.returnType.testClassLocalFieldName #else $testInfo.method.returnType.initExpression #end")
            #assertEqualsCall($macro.expectedValueExpression, 'result', $testInfo.method.returnType);
        #end
    #end
        }
#end

##----------------------------------------------------------------------------------------------------------------------
## renderSimpleMultivalueTestMethodForEnum($testInfo)
## Renders a simple test method for the given $testInfo. The method contains assertions for all
## values in the enum.
## Param: $testInfo - information about which case this test should cover.
##----------------------------------------------------------------------------------------------------------------------
#macro(initializeTemplateDataModel)
    ## Define ListenableFuture to SettableFutures map.
    ## If your company uses a fork of ListenableFuture, add an entry here to improve test generation.
    ## The format is: 'ListenableFutureCanonicalName' : ['SettableFutureCanonicalName', 'SettableFutureInitExpression'].
    #set($ListenableFutureToSettableFutureMap = {
        'com.google.common.util.concurrent.ListenableFuture':
    ['com.google.common.util.concurrent.SettableFuture', 'com.google.common.util.concurrent.SettableFuture.create()'],
        'com.google.common.util.concurrent.SettableFuture':
    ['com.google.common.util.concurrent.SettableFuture', 'com.google.common.util.concurrent.SettableFuture.create()'],
        'com.google.api.core.ApiFuture':
    ['com.google.api.core.SettableApiFuture', 'com.google.api.core.SettableApiFuture.create()'],
        'com.google.api.core.SettableApiFuture':
    ['com.google.api.core.SettableApiFuture', 'com.google.api.core.SettableApiFuture.create()'],
        'org.springframework.util.concurrent.ListenableFuture':
    ['org.springframework.util.concurrent.SettableListenableFuture', 'new org.springframework.util.concurrent.SettableListenableFuture<>()'],
        'org.springframework.util.concurrent.SettableListenableFuture':
    ['org.springframework.util.concurrent.SettableListenableFuture', 'new org.springframework.util.concurrent.SettableListenableFuture<>()']
    })
    #set($ListenableFutureNames = $ListenableFutureToSettableFutureMap.keySet())
    #set($BooleanTypes = ['boolean', 'java.lang.Boolean'])
    #set($NumericTypes = ['int', 'float', 'double', 'short', 'char', 'long', 'byte', 'java.lang.Number', 'java.lang.Character'])
    #set($MultipartInterfaceTypes = ['org.springframework.web.multipart.MultipartFile', 'javax.servlet.http.Part', 'org.springframework.http.codec.multipart.Part'])
    #set($IgnoredControllerTypes = ['org.springframework.web.context.request.WebRequest', 'javax.servlet.ServletRequest', 'javax.servlet.ServletResponse',
        'javax.servlet.http.HttpSession', 'javax.servlet.http.PushBuilder', 'org.springframework.http.HttpMethod', 'java.util.TimeZone', 'java.time.ZoneId',
        'java.io.InputStream', 'java.io.Reader', 'java.io.OutputStream', 'java.io.Writer', 'java.util.Map', 'org.springframework.ui.Model', 'org.springframework.ui.ModelMap',
        'org.springframework.web.servlet.mvc.support.RedirectAttributes', 'org.springframework.validation.Errors', 'org.springframework.web.bind.support.SessionStatus',
        'org.springframework.web.util.UriComponentsBuilder'])
    #set($RequestMappingAnnotations = ['DeleteMapping', 'GetMapping', 'PatchMapping', 'PostMapping', 'PutMapping', 'RequestMapping', 'NotificationMessageMapping'])
    #set($ControllerMethodAnnotations = ['DeleteMapping', 'GetMapping', 'PatchMapping', 'PostMapping', 'PutMapping', 'RequestMapping', 'ResponseBody', 'ResponseStatus', 'NotificationMessageMapping'])
    #set($SecurityAnnotations = ['PreAuthorize', 'PostAuthorize', 'PreFilter', 'PostFilter', 'Secured'])
    #set($ControllerParameterAnnotations = ['PathVariable', 'MatrixVariable', 'RequestParam', 'RequestHeader', 'CookieValue', 'RequestBody', 'RequestPart', 'ModelAttribute', 'SessionAttribute', 'RequestAttribute'])

    ## Determine information about JUnit and Mockito versions on the test classpath.
    #set($hasOpenMocksMethod = false)
    #set($initMocksMethodName = 'initMocks')
    #set($macro.mockitoAnnotationsSourceClass = $ClassUtils.resolveClass('org.mockito.MockitoAnnotations'))
    #if($macro.mockitoAnnotationsSourceClass && $macro.mockitoAnnotationsSourceClass.methods.containsAnyWith('name', 'openMocks'))
        #set($hasOpenMocksMethod = true)
        #set($initMocksMethodName = 'openMocks')
    #end
    #set($mockitoRunnerCanonicalName = 'org.mockito.junit.MockitoJUnitRunner')
    #set($mockitoRunnerName = 'MockitoJUnitRunner')
    #if(!$ClassUtils.isInTestClasspath('org.mockito.junit.MockitoJUnitRunner') && $ClassUtils.isInTestClasspath('org.mockito.runners.MockitoJUnitRunner'))
        #set($mockitoRunnerCanonicalName = 'org.mockito.runners.MockitoJUnitRunner')
    #end

    ## Determine if the source class is a Spring controller.
    #set($macro.superClasses = $FluentList.of($sourceClass).concat($sourceClass.allSuperClasses))
    #set($springController = $macro.superClasses.containsAnyWithAnnotation('org.springframework.stereotype.Controller', 'org.springframework.web.bind.annotation.RestController'))
    #set($restController = $macro.superClasses.containsAnyWithAnnotation('org.springframework.web.bind.annotation.RestController')
    || ($macro.superClasses.containsAnyWithAnnotation('org.springframework.stereotype.Controller') && $macro.superClasses.containsAnyWithAnnotation('org.springframework.web.bind.annotation.ResponseBody')))
    #set($hasClassSecurityAnnotations = $macro.superClasses.containsAnyWithAnnotation($SecurityAnnotations))

    ## Determine which methods in the source class are controller methods.
    #set($controllerMethods = $FluentList.of())
    #if($springController)
        #foreach($method in $sourceClass.methods)
            #if($method.hasAnnotation($ControllerMethodAnnotations)
            || ($method.superMethods.containsAnyWithAnnotation($ControllerMethodAnnotations)))
                #set($_ = $controllerMethods.add($method))
            #end
        #end
    #end
    #set($allModelAttributeProviderMethods = $macro.superClasses.flatMap('methods').filterItemsWithAnnotation('ModelAttribute').filterOutItemsWithAnnotation($ControllerMethodAnnotations))
    #set($modelAttributeProviderMethods = $sourceClass.methods.filterItemsWithAnnotation('ModelAttribute').filterOutItemsWithAnnotation($ControllerMethodAnnotations))
    #set($modelAttributeProviderMethodDIs = $allModelAttributeProviderMethods.flatMap('dependencyInteractions'))
    #if($springController && $sourceClass.preferredConstructor && !$sourceClass.preferredConstructor.hasAnnotation('Autowired'))
        ## Use the @Autowired constructor if available.
        #set($macro.newPreferredConstructor = $sourceClass.constructorsAnnotatedWith('Autowired').first)
        #if($macro.newPreferredConstructor)
            #set($sourceClass.preferredConstructor = $macro.newPreferredConstructor)
        #end
    #end
    ## Determine the base path for the controller class if there is one.
    #set($basePath = '')
    #set($macro.annotationPath = $macro.superClasses.flatMap('annotations').filter('name', 'RequestMapping').flatMap('parameters').filter('key', 'path', 'value').filterOut('value.text', '{}').first.value.text)
    ## Replace environment variable placeholders like ${companyName} with the String: companyName.
    #set($macro.tempBasePath = $StringUtils.replaceAll($macro.annotationPath, '\$\{(.*?)\}', '/$1/'))
    #set($macro.tempBasePath = $StringUtils.replaceAll($macro.tempBasePath, '/+', '/'))
    ## The path can be a String[] with multiple Strings. Take the longest substring between two double quote chars.
    #set($macro.tempBasePath = $StringUtils.longest($StringUtils.substringsBetween($macro.tempBasePath, '"')))
    #if($macro.tempBasePath)
        #set($basePath = $macro.tempBasePath)
    #elseif($macro.annotationPath)
        ## The path could be a reference to a constant; e.g. MyPaths.FooPath.
        #set($basePath = 'basePath')
    #end
    #set($mockMvcMemberName = "$CodeStyleUtils.suggestMemberName('MockMvc')")
    #if($shouldUseMockitoBdd)
        #set($doAnswer = 'willAnswer')
        #set($doReturn = 'willReturn')
        #set($thenReturn = 'willReturn')
        #set($when = 'given')
        #set($doThrow = 'willThrow')
        #set($thenThrow = 'willThrow')
    #else
        #set($doAnswer = 'doAnswer')
        #set($doReturn = 'doReturn')
        #set($thenReturn = 'thenReturn')
        #set($when = 'when')
        #set($doThrow = 'doThrow')
        #set($thenThrow = 'thenThrow')
    #end
    ## Determine the archetype of the source class and set the global variables accordingly.
    #set($shouldCreateTestsForInstanceMethods = true)
    #set($mutablePackageLocalInstanceFields = $sourceClass.packageLocalInstanceFields.filter('final', false))
    ## Add the simple names or cannonical names of any custom dependency annotations to the method call below.
    #set($dependencyAnnotatedFields = $sourceClass.fieldsAnnotatedWith('Inject', 'Autowired', 'Resource', 'PersistenceContext'))
    #if($sourceClass.enum)
        #set($dependencies = $FluentList.emptyList())
        #set($sourceClassMemberNeeded = false)
    #elseif($sourceClass.instanceMethods.empty && !$sourceClass.staticMethods.empty)
        ## The source class only has static methods; it's likely a utils class.
        #set($dependencies = $FluentList.emptyList())
        #set($sourceClassMemberNeeded = false)
    #elseif($sourceClass.abstract && !$sourceClass.packageVisibleStaticCreatorMethods.empty)
        ## The source class is abstract and has static creator methods. Only create tests for those. The static creator
        ## test methods invoke the instance methods.
        #set($dependencies = $FluentList.emptyList())
        #set($sourceClassMemberNeeded = false)
        #set($shouldCreateTestsForInstanceMethods = false)
    #elseif($sourceClass.sealedAbstract)
        ## The source class is a sealed abstract class. If we have a preferred constructor, use its arguments for the
        ## dependencies. That way the user can simply replace the constructor call with its appropriate subclass constructor call.
        #if($sourceClass.preferredConstructor)
            #set($dependencies = $sourceClass.preferredConstructor.parameters)
        #else
            #set($dependencies = $FluentList.emptyList())
        #end
        #set($sourceClassMemberNeeded = true)
    #elseif($sourceClass.abstract && !$sourceClass.preferredConstructor)
        ## The source class is an abstract class, but does not have a visible constructor or static creator methods.
        #set($dependencies = $FluentList.emptyList())
        #set($sourceClassMemberNeeded = true)
    #elseif($sourceClass.preferredConstructor && !$sourceClass.preferredConstructor.parameters.empty)
        ## The source class has a parameterized constructor; use it to provide the dependencies.
        #set($dependencies = $sourceClass.preferredConstructor.parameters)
        #set($sourceClassMemberNeeded = true)
    #elseif($sourceClass.preferredConstructor && !$dependencyAnnotatedFields.filter('private', true).empty)
        ## The source class has a no-args constructor and private fields annotated with @Inject or @Autowired.
        #set($shouldUseInjectMocks = true)
        #set($dependencies = $dependencyAnnotatedFields)
        #set($sourceClassMemberNeeded = true)
    #elseif($sourceClass.preferredConstructor && !$dependencyAnnotatedFields.empty)
        ## The source class has a no-args constructor and visible, dependency-annotated fields;
        ## the test class should set them.
        #set($dependencies = $dependencyAnnotatedFields)
        #set($shouldSetPackageLocalFields = true)
        #set($sourceClassMemberNeeded = true)
    #elseif($sourceClass.preferredConstructor && !$mutablePackageLocalInstanceFields.empty)
        ## The source class has a no-args constructor and mutable package-local instance fields; assume they are
        ## dependencies and have the test class set them.
        #set($dependencies = $mutablePackageLocalInstanceFields)
        #set($shouldSetPackageLocalFields = true)
        #set($sourceClassMemberNeeded = true)
    #elseif($sourceClass.preferredConstructor)
        ## The source class has a visible constructor but no package-local fields or dependency-annotated fields.
        #set($dependencies = $FluentList.emptyList())
        #set($sourceClassMemberNeeded = true)
    #elseif($sourceClass.singleton)
        #set($dependencies = $FluentList.emptyList())
        #set($sourceClassMemberNeeded = true)
    #elseif(!$sourceClass.packageVisibleStaticCreatorMethods.empty)
        ## The source class has no visible constructor, but does have static creator methods; e.g. parse(...), from(...).
        #set($dependencies = $FluentList.emptyList())
        #set($sourceClassMemberNeeded = false)
        #set($shouldCreateTestsForInstanceMethods = false)
    #else
        #set($dependencies = $FluentList.emptyList())
        #set($sourceClassMemberNeeded = true)
    #end
    #if($springController)
        #set($sourceClassMemberNeeded = false)
        #set($shouldSetPackageLocalFields = false)
    #end
    ## Update the mutable fields on the dependencies based on the Quick Settings.
    #setDependencyNamesAndInitExpressions($dependencies, $shouldUseInjectMocks, $shouldSetPackageLocalFields)
    ## Filter out fields that should not be stored as members in the test class.
    #set($memberFields = $dependencies.filter('shouldStoreInReference', true))
    #set($mockMemberFields = $memberFields.filter('shouldBeMocked', true))
    #set($nonMockMemberFields = $memberFields.filter('shouldBeMocked', false))
    #set($mocksNeeded = !$mockMemberFields.empty || $shouldUseInjectMocks)
    ## Determine if we have Assert.assertThrows(..).
    #set($macro.assertClass = $ClassUtils.resolveClass('org.junit.Assert'))
    #if($macro.assertClass && $macro.assertClass.methods.containsAnyWith('name', 'assertThrows'))
        #set($hasAssertThrows = true)
    #else
        #set($hasAssertThrows = false)
    #end
    #initializeMethodParamsWithQuickSettings()
    #initializeMethodReturnTypes()
    #initializeDependencyInteractionMethodParams()
    #askUserToConfirmSettingsIfNeeded()
#end

##----------------------------------------------------------------------------------------------------------------------
## initializeMethodReturnTypes()
## Sets the returnType.testClassLocalFieldName of each method to 'expectedResult'.
##----------------------------------------------------------------------------------------------------------------------
#macro(initializeMethodReturnTypes)
    #foreach($method in $sourceClass.allMethods)
        #if($method.returnType)
            #if($sourceClass.packageVisibleStaticCreatorMethods.contains($method))
                #set($method.returnType.testClassLocalFieldName = 'result')
            #else
                #set($method.returnType.testClassLocalFieldName = 'expectedResult')
            #end
        #end
    #end
#end

##----------------------------------------------------------------------------------------------------------------------
## initializeMethodParamsWithQuickSettings()
## Sets mutable fields on the method parameters based on Quick Settings.
##----------------------------------------------------------------------------------------------------------------------
#macro(initializeMethodParamsWithQuickSettings)
    #foreach($method in $sourceClass.allMethods)
        #foreach($param in $method.parameters)
            #if($param.type.generic && $sourceClass.packageVisibleStaticCreatorMethods.contains($method))
                ## Use inline args for generic types in static creator methods; e.g. Pair.of(left, right), ImmutableList.of(T...).
                #set($param.shouldStoreInReference = false)
            #elseif($useMocksForListenerAndCallbackParameters
            && $param.type.mockable
            && ($StringUtils.endsWithIgnoreCase($param.declaredName, "listener")
            || $StringUtils.endsWithIgnoreCase($param.declaredName, "callback")))
                ## If useMocksForListenerAndCallbackParameters is set it takes precedence over any initExpressionOverrides.
                #if($param.used)
                    #useInlineMockForParam($param)
                    #set($param.shouldStoreInReference = true)
                #else
                    #set($param.shouldStoreInReference = false)
                #end
            #elseif(!$param.used && $param.type.initExpression == 'null')
                #set($param.shouldStoreInReference = false)
            #elseif($initExpressionOverrides.containsKey($param.type.canonicalName))
                ## Check the initExpressionOverrides.
                #set($macro.initExpressionOverride = false)
                #set($macro.initExpressionOverride = $initExpressionOverrides.get($param.type.canonicalName))
                #if($macro.initExpressionOverride)
                    #set($param.initExpression = $macro.initExpressionOverride.initExpression)
                    #set($param.shouldStoreInReference = $macro.initExpressionOverride.shouldStoreInReference)
                    #set($param.shouldBeMocked = false)
                    #set($_ = $importLinesRequired.addAll($ListUtils.nullToEmpty($macro.initExpressionOverride.importsRequired)))
                #end
            #elseif($param.type.recognized && $param.type.shouldBeMocked)
                #useInlineMockForParam($param)
                #set($param.shouldStoreInReference = true)
            #else
                #set($param.shouldBeMocked = false)
            #end
            #setTestClassNamesForParam($param)
        #end
    #end
#end

##----------------------------------------------------------------------------------------------------------------------
## setDependencyNamesAndInitExpressions($dependencies, $shouldUseInjectMocks, $shouldSetPackageLocalFields)
## Sets mutable fields on the $params based on the Quick Settings.
## Param: $dependencies the List<Variable> containing the dependencies.
## Param: $shouldUseInjectMocks
##          a boolean indicating whether or not @InjectMocks should be used to provide dependencies to the instance
##          of the source class.
## Param: $shouldSetPackageLocalFields
##          a boolean indicating whether or not the test class should provide dependencies to the source class by
##          setting package-local fields.
##----------------------------------------------------------------------------------------------------------------------
#macro(setDependencyNamesAndInitExpressions $dependencies, $shouldUseInjectMocks, $shouldSetPackageLocalFields)
    #foreach($dependency in $dependencies)
        ## Use the initExpressionOverride if one is present and we do not need to use @InjectMocks.
        #set($macro.initExpressionOverride = false)
        #set($macro.initExpressionOverride = $initExpressionOverrides.get($dependency.type.canonicalName))
        #if($macro.initExpressionOverride && !$shouldUseInjectMocks)
            #set($dependency.initExpression = $macro.initExpressionOverride.initExpression)
            #set($dependency.shouldStoreInReference = $macro.initExpressionOverride.shouldStoreInReference)
            #set($dependency.shouldBeMocked = false)
            #set($_ = $importLinesRequired.addAll($ListUtils.nullToEmpty($macro.initExpressionOverride.importsRequired)))
        #elseif($shouldUseInjectMocks && $dependency.type.mockable)
            #set($dependency.shouldBeMocked = true)
            #set($dependency.shouldStoreInReference = true)
        #elseif(!$dependency.shouldBeMocked)
            #set($dependency.shouldStoreInReference = false)
        #end
        ## If the dependencies are provided by setting package-local fields, set them inline instead of storing
        ## references to them in the test class.
        #if($shouldSetPackageLocalFields)
            #if($dependency.shouldBeMocked)
                #useInlineMockForParam($dependency)
            #end
            #set($dependency.shouldStoreInReference = false)
        #end
        #setTestClassNamesForParam($dependency)
    #end
#end

##----------------------------------------------------------------------------------------------------------------------
## initializeDependencyInteractionMethodParams()
## Updates the data model to use inline initialization expressions for the method arguments in stub (when) and verify
## expressions.
##----------------------------------------------------------------------------------------------------------------------
#macro(initializeDependencyInteractionMethodParams)
    #foreach($method in $sourceClass.allMethods)
        #foreach($di in $method.dependencyInteractions)
            #initializeDependencyInteractionMethodReturnType($di)
            ## Set the parameter init expressions to either values or matcher expressions.
            #set($macro.hasCallableOrRunnableParam = $di.method.parameters.containsAnyWith('type.canonicalName', 'java.util.concurrent.Callable','java.lang.Runnable'))
            #set($macro.hasParamRequiringMatcher = $macro.hasCallableOrRunnableParam || $di.methodCallExpression.arguments.filterOut('actualType.primitive').filterOut('declaredType.classT').containsAnyWith('actualType.overridesEquals', false))
            #foreach($param in $di.method.parameters)
                #set($macro.actualType = $di.methodCallExpression.arguments.get($foreach.index).actualType)
                #set($param.shouldStoreInReference = false)
                ## Handle Callables and Runnables.
                #if($param.type.canonicalName == 'java.util.concurrent.Callable')
                    #set($param.initExpression = '(Callable<?>) any(Callable.class)')
                #elseif($param.type.canonicalName == 'java.lang.Runnable')
                    #set($param.initExpression = 'any(Runnable.class)')
                    ## Handle Class<T> arguments; e.g. Foo.class.
                #elseif($param.type.classT)
                    #set($macro.classExpression = "${macro.actualType.canonicalNameOrName}.class")
                    #if($macro.hasParamRequiringMatcher)
                        #set($param.initExpression = "eq($macro.classExpression)")
                    #else
                        #set($param.initExpression = "$macro.classExpression")
                    #end
                    ## Handle generic type arguments; e.g. T, not List<T>.
                #elseif($param.type.generic)
                    #if(!$macro.hasParamRequiringMatcher)
                        ## Use values for all arguments.
                        #set($param.initExpression = $macro.actualType.initExpression)
                    #elseif($macro.actualType.primitive || $macro.actualType.overridesEquals)
                        ## We need to use matchers. Use eq(...) if possible.
                        #set($param.initExpression = "eq($macro.actualType.initExpression)")
                    #else
                        ## We need to use matchers. A custom matcher is needed to validate the argument. Use any(...) for now.
                        #set($param.initExpression = "any(${macro.actualType.canonicalNameOrName}.class)")
                    #end
                    ## Handle the case where the formal parameter is an interface or abstract class that does not override
                    ## Object.equals, but the actual type does.
                #elseif(!$param.type.overridesEquals && $macro.actualType.overridesEquals)
                    #if(!$macro.hasParamRequiringMatcher)
                        ## Use values for all arguments.
                        #set($param.initExpression = $macro.actualType.initExpression)
                    #else
                        ## We need to use matchers. Use eq(...).
                        #set($param.initExpression = "eq($macro.actualType.initExpression)")
                    #end
                    ## Handle all remaining cases where we need to use matchers.
                #elseif($macro.hasParamRequiringMatcher)
                    #if($param.type.primitive || $param.type.overridesEquals || $macro.actualType.overridesEquals)
                        ## We need to use matchers. Use eq(...) if possible.
                        #set($param.initExpression = "eq($param.initExpression)")
                    #else
                        ## We need to use matchers. A custom matcher is needed to validate the argument. Use any(...) for now.
                        #set($param.initExpression = "any(${param.type.canonicalNameOrName}.class)")
                    #end
                #end
            #end
        #end
    #end
#end

##----------------------------------------------------------------------------------------------------------------------
## initializeDependencyInteractionMethodReturnType($di)
## Initializes the initExpression, testClassLocalFieldName and other fields in the $di.method.returnType.
## Param: $di the dependency interaction whose return type will be initialized.
##----------------------------------------------------------------------------------------------------------------------
#macro(initializeDependencyInteractionMethodReturnType $di)
    #if($di.method.returnType.dtoBean || !$di.method.returnType.initExpressionBeans.empty)
        #set($di.method.returnType.shouldStoreInReference = true)
    #end
    #if($ListenableFutureNames.contains($di.method.returnType.canonicalName))
        #set($di.method.returnType.shouldStoreInReference = true)
    #end
    #if($di.method.returnType.closeable)
        #set($di.method.returnType.shouldStoreInReference = true)
        #if($di.method.returnType.initExpression.equals('null'))
            #set($di.method.returnType.shouldBeMocked = true)
        #else
            #useInlineSpyForParam($di.method.returnType)
            #set($di.method.returnType.testClassLocalFieldName = "spy$StringUtils.capitalize($di.method.returnType.name)")
        #end
    #end
    #if($di.method.returnType.shouldBeMocked)
        #set($di.method.returnType.shouldStoreInReference = true)
        #useInlineMockForParam($di.method.returnType)
        #set($di.method.returnType.testClassLocalFieldName = "mock$StringUtils.capitalize($di.method.returnType.name)")
    #end
    #if($ClassUtils.removePackageQualifiers($di.method.returnType.initExpression).length() > 40)
        #set($di.method.returnType.shouldStoreInReference = true)
    #end
#end

##----------------------------------------------------------------------------------------------------------------------
## setTestClassNamesForParam($param)
## Sets the Variable.testClassMemberName and Variable.testClassLocalFieldName properties on the given $param
## based on the Quick Settings.
## Param: $param the Variable to update
##----------------------------------------------------------------------------------------------------------------------
#macro(setTestClassNamesForParam $param)
    #if($param.shouldBeMocked)
        #if(${StringUtils.isNotEmpty($mockDependencyMemberNamePrefix)})
            #set($param.testClassMemberName = "${mockDependencyMemberNamePrefix}${StringUtils.capitalize(${param.declaredNameWithoutPrefix})}")
        #elseif (${StringUtils.isNotEmpty($dependencyMemberNamePrefix)})
            #set($param.testClassMemberName = "${dependencyMemberNamePrefix}${StringUtils.capitalize(${param.declaredNameWithoutPrefix})}")
        #end
        #if(${StringUtils.isNotEmpty($mockParameterLocalFieldNamePrefix)})
            #set($param.testClassLocalFieldName = "${mockParameterLocalFieldNamePrefix}${StringUtils.capitalize(${param.declaredNameWithoutPrefix})}")
        #elseif (${StringUtils.isNotEmpty($parameterLocalFieldNamePrefix)})
            #set($param.testClassLocalFieldName = "${parameterLocalFieldNamePrefix}${StringUtils.capitalize(${param.declaredNameWithoutPrefix})}")
        #end
    #else
        #if(${StringUtils.isNotEmpty($dependencyMemberNamePrefix)})
            #set($param.testClassMemberName = "${dependencyMemberNamePrefix}${StringUtils.capitalize(${param.declaredNameWithoutPrefix})}")
        #end
        #if(${StringUtils.isNotEmpty($parameterLocalFieldNamePrefix)})
            #set($param.testClassLocalFieldName = "${parameterLocalFieldNamePrefix}${StringUtils.capitalize(${param.declaredNameWithoutPrefix})}")
        #end
    #end
#end

##----------------------------------------------------------------------------------------------------------------------
## useInlineMockForParam($param)
## Updates the given parameter to use an inline mock expression; e.g. mock(Foo.class) wherever the parameter is needed.
## Param: $param the Variable to update
##----------------------------------------------------------------------------------------------------------------------
#macro(useInlineMockForParam $param)
    #if($useStaticImportForInitMocks)
        #set($param.initExpression = "mock(${param.type.canonicalName}.class)")
        #if($param.type.isAny('java.lang.Iterable'))
            #set($param.type.emptyInitExpression = "mock(${param.type.canonicalName}.class)")
        #end
        #set($_ = $importLinesRequired.add("import static org.mockito.Mockito.mock;"))
    #else
        #set($param.initExpression = "Mockito.mock(${param.type.canonicalName}.class)")
        #if($param.type.isAny('java.lang.Iterable'))
            #set($param.type.emptyInitExpression = "mock(${param.type.canonicalName}.class)")
        #end
        #set($_ = $importLinesRequired.add("import org.mockito.Mockito;"))
    #end
    #set($param.shouldBeMocked = true)
#end

##----------------------------------------------------------------------------------------------------------------------
## useInlineSpyForParam($param)
## Updates the given parameter to use an inline mock expression; e.g. mock(Foo.class) wherever the parameter is needed.
## Param: $param the Variable to update
##----------------------------------------------------------------------------------------------------------------------
#macro(useInlineSpyForParam $param)
    #if($useStaticImportForInitMocks)
        #set($param.initExpression = "spy($param.initExpression)")
        #if($param.type.emptyInitExpression)
            #set($param.type.emptyInitExpression = "spy($param.type.emptyInitExpression)")
        #end
        #if($param.type.absentInitExpression && !$StringUtils.equals($param.type.absentInitExpression, 'null'))
            #set($param.type.absentInitExpression = "spy($param.type.absentInitExpression)")
        #end
        #if($param.type.emptyIoInitExpression)
            #set($param.type.emptyIoInitExpression = "spy($param.type.emptyIoInitExpression)")
        #end
        #if($param.type.brokenIoInitExpression)
            #set($param.type.brokenIoInitExpression = "spy($param.type.brokenIoInitExpression)")
        #end
        #set($_ = $importLinesRequired.add("import static org.mockito.Mockito.spy;"))
    #else
        #set($param.initExpression = "Mockito.spy($param.initExpression)")
        #if($param.type.emptyInitExpression)
            #set($param.type.emptyInitExpression = "Mockito.spy($param.type.emptyInitExpression)")
        #end
        #if($param.type.absentInitExpression && !$StringUtils.equals($param.type.absentInitExpression, 'null'))
            #set($param.type.absentInitExpression = "Mockito.spy($param.type.absentInitExpression)")
        #end
        #if($param.type.emptyIoInitExpression)
            #set($param.type.emptyIoInitExpression = "Mockito.spy($param.type.emptyIoInitExpression)")
        #end
        #if($param.type.brokenIoInitExpression)
            #set($param.type.brokenIoInitExpression = "Mockito.spy($param.type.brokenIoInitExpression)")
        #end
        #set($_ = $importLinesRequired.add("import org.mockito.Mockito;"))
    #end
    #set($param.shouldBeMocked = false)
    #set($param.shouldBeSpied = true)
#end

##----------------------------------------------------------------------------------------------------------------------
## askUserToConfirmSettingsIfNeeded()
## Shows a dialog asking the user to confirm which dependencies should be mocked if the template was invoked with
## $shouldAskToConfirmSettings = true. The variable: $shouldAskToConfirmSettings is true when the user invokes the
## "Generate Test - Confirm Mocks" action from the Squaretest menu.
##----------------------------------------------------------------------------------------------------------------------
#macro(askUserToConfirmSettingsIfNeeded)
    #if($shouldAskToConfirmSettings)
        ## Show the dialog to ask the user to confirm the provided settings.
        #set($userProvidedSettings =
            $UiUtils.askUserToConfirmSettings({
                'dependencies' : $dependencies,
                'memberFields' : $memberFields,
                'mockMemberFields' : $mockMemberFields,
                'nonMockMemberFields' : $nonMockMemberFields,
                'sourceClassMemberNeeded' : $sourceClassMemberNeeded,
                'shouldUseInjectMocks' : $shouldUseInjectMocks,
                'shouldSetPackageLocalFields' : $shouldSetPackageLocalFields,
                'mocksNeeded' : $mocksNeeded,
                'shouldCreateTestsForInstanceMethods' : $shouldCreateTestsForInstanceMethods
            }))
        #set($dependencies = $userProvidedSettings.get('dependencies'))
        #set($memberFields = $userProvidedSettings.get('memberFields'))
        #set($mockMemberFields = $userProvidedSettings.get('mockMemberFields'))
        #set($nonMockMemberFields = $userProvidedSettings.get('nonMockMemberFields'))
        #set($sourceClassMemberNeeded = $userProvidedSettings.get('sourceClassMemberNeeded'))
        #set($shouldUseInjectMocks = $userProvidedSettings.get('shouldUseInjectMocks'))
        #set($shouldSetPackageLocalFields = $userProvidedSettings.get('shouldSetPackageLocalFields'))
        #set($mocksNeeded = $userProvidedSettings.get('mocksNeeded'))
        #set($shouldCreateTestsForInstanceMethods = $userProvidedSettings.get('shouldCreateTestsForInstanceMethods'))
    #end
#end

## Declare global variables set by initializeTemplateDataModel() to enable partial code completion in the Velocity
## editor bundled with the IntelliJ IDEA Ultimate Edition.
## Constants.
#* @vtlvariable name="ListenableFutureNames" type="java.util.Set<java.lang.String>" *#
#* @vtlvariable name="ListenableFutureToSettableFutureMap" type="java.util.Map<java.lang.String, java.util.List<java.lang.String>>" *#

## General data types.
#* @vtlvariable name="dependencies" type="com.squaretest.template.api.Api.FluentList<com.squaretest.template.api.Api.Variable>" *#
#* @vtlvariable name="memberFields" type="com.squaretest.template.api.Api.FluentList<com.squaretest.template.api.Api.Variable>" *#
#* @vtlvariable name="mockMemberFields" type="com.squaretest.template.api.Api.FluentList<com.squaretest.template.api.Api.Variable>" *#
#* @vtlvariable name="nonMockMemberFields" type="com.squaretest.template.api.Api.FluentList<com.squaretest.template.api.Api.Variable>" *#
#* @vtlvariable name="sourceClassMemberNeeded" type="boolean" *#
#* @vtlvariable name="shouldUseInjectMocks" type="boolean" *#
#* @vtlvariable name="shouldSetPackageLocalFields" type="boolean" *#
#* @vtlvariable name="mocksNeeded" type="boolean" *#
#* @vtlvariable name="shouldCreateTestsForInstanceMethods" type="boolean" *#
#* @vtlvariable name="initMocksMethodName" type="java.lang.String" *#
#* @vtlvariable name="hasOpenMocksMethod" type="boolean" *#
#* @vtlvariable name="mockitoRunnerCanonicalName" type="java.lang.String" *#
#* @vtlvariable name="mockitoRunnerName" type="java.lang.String" *#

## Variables defined based on whether the $shouldUseMockitoBdd setting is enabled.
#* @vtlvariable name="doAnswer" type="java.lang.String" *#
#* @vtlvariable name="doReturn" type="java.lang.String" *#
#* @vtlvariable name="thenReturn" type="java.lang.String" *#
#* @vtlvariable name="when" type="java.lang.String" *#
#* @vtlvariable name="doThrow" type="java.lang.String" *#
#* @vtlvariable name="thenThrow" type="java.lang.String" *#

## Parameter names used in various macros.
#* @vtlvariable name="testInfo" type="com.squaretest.template.api.Api.TestInfo" *#
#* @vtlvariable name="exceptionToThrow" type="com.squaretest.template.api.Api.Exception" *#
#* @vtlvariable name="dependency" type="com.squaretest.template.api.Api.Variable" *#
#* @vtlvariable name="methods" type="com.squaretest.template.api.Api.FluentList<com.squaretest.template.api.Api.Method>" *#
#* @vtlvariable name="method" type="com.squaretest.template.api.Api.Method" *#
#* @vtlvariable name="param" type="com.squaretest.template.api.Api.Variable" *#
#* @vtlvariable name="typeOrVariable" type="com.squaretest.template.api.Api.Variable" *#
#* @vtlvariable name="type" type="com.squaretest.template.api.Api.Type" *#
#* @vtlvariable name="field" type="com.squaretest.template.api.Api.Variable" *#
#* @vtlvariable name="di" type="com.squaretest.template.api.Api.DependencyInteraction" *#
#* @vtlvariable name="testCaseSuffix" type="java.lang.String" *#
#* @vtlvariable name="beanSourceClass" type="com.squaretest.template.api.Api.SourceClass" *#
#* @vtlvariable name="shouldUseEmptyIo" type="boolean" *#
#* @vtlvariable name="shouldUseBrokenIo" type="boolean" *#
#* @vtlvariable name="numberOfSettersCalled" type="org.apache.commons.lang3.mutable.MutableInt" *#
#* @vtlvariable name="canonicalNamesInCallStack" type="java.util.Map<java.lang.String, java.lang.Boolean>" *#